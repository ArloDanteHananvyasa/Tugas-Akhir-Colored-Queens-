\documentclass[a4paper,twoside]{article}
\usepackage[T1]{fontenc}
\usepackage[bahasa]{babel}
\usepackage{graphicx}
\usepackage{graphics}
\usepackage{float}
\usepackage{listings}
\usepackage{xcolor} % optional for custom colors
\usepackage[cm]{fullpage}
\pagestyle{myheadings}
\usepackage{etoolbox}
\usepackage{setspace} 
\usepackage{lipsum} 
\setlength{\headsep}{30pt}
\usepackage[inner=2cm,outer=2.5cm,top=2.5cm,bottom=2cm]{geometry} %margin
% \pagestyle{empty}
\usepackage{subcaption}
\usepackage{url}
\usepackage{hyperref}
\hypersetup{
	colorlinks=true,
	linkcolor=blue,
	urlcolor=blue,
	citecolor=blue
}
\usepackage{amsmath}
\usepackage{enumitem}
\usepackage{amssymb}

\lstset{numbers=left,stepnumber=1, numbersep=5pt, frame=single,frameround={tttt},
	tabsize=4, breaklines=true, basicstyle=\fontfamily{fvm}\selectfont\tiny, 
	commentstyle=\itshape\color{gray}, keywordstyle=\bfseries\color{blue}, 
	identifierstyle=\color{black}, stringstyle=\color{orange},
	literate={-}{-}1{-\,-}{--}1
} 

\usepackage[useregional=false]{datetime2}

\DeclareCaptionLabelFormat{subfig}{\figurename~#1#2}
\captionsetup[subfigure]{labelformat=subfig, labelsep=colon}
\renewcommand\thesubfigure{\alph{subfigure}}

\DeclareCaptionLabelFormat{subfig}{\figurename~\thefigure(\thesubfigure)}
\captionsetup[subfigure]{labelformat=subfig, labelsep=colon}

\DTMsetdatestyle{ddmmyyyy}
\DTMsetup{datesep=/}
\renewcommand{\figurename}{Gambar}

\graphicspath{{./Gambar/}}% folder tempat gambar 

\makeatletter
\renewcommand{\@maketitle} {\begin{center} {\LARGE \textbf{ \textsc{\@title}} \par} \bigskip {\large \textbf{\textsc{\@author}} }\end{center} }
\renewcommand{\thispagestyle}[1]{}
\markright{\textbf{\textsc{Laporan Perkembangan Pengerjaan Tugas Akhir\textemdash Sem. Ganjil 2025/2026}}}

\onehalfspacing

\begin{document}
	
	\title{\@judultopik}
	\author{\nama \textendash \@npm} 
	
	%ISILAH DATA BERIKUT INI:
	\newcommand{\nama}{Arlo Dante Hananvyasa}
	\newcommand{\@npm}{6182201010}
	\newcommand{\tanggal}{\DTMtoday} %Tanggal pembuatan dokumen
	\newcommand{\@judultopik}{Pembangunan Perangkat Lunak dan
		Penyelesaian Permainan Colored Queens} % Judul/topik anda
	\newcommand{\kodetopik}{HUH5902ACS}
	\newcommand{\jumpemb}{1} % Jumlah pembimbing, 1 atau 2
	\newcommand{\pembA}{Husnul~Hakim,~M.T.}
	\newcommand{\pembB}{-}
	\newcommand{\semesterPertama}{59 - Ganjil 25/26} % semester pertama kali topik diambil, angka 1 dimulai dari sem Ganjil 96/97
	\newcommand{\lamaSkripsi}{1} % Jumlah semester untuk mengerjakan tugas akhir s.d. dokumen ini dibuat
	\newcommand{\kulPertama}{Tugas Akhir 1} % Kuliah dimana topik ini diambil pertama kali
	\newcommand{\tipePR}{B} % tipe progress report :
	% A : dokumen pendukung untuk pengambilan ke-2 di Tugas Akhir 1
	% B : dokumen untuk reviewer pada presentasi dan review Tugas Akhir 1
	% C : dokumen pendukung untuk pengambilan ke-2 di Tugas Akhir 2
	
	
	% Dokumen hasil template ini harus dicetak bolak-balik !!!!
	
	\maketitle
	
	\pagenumbering{arabic}
	
	\section{Data Tugas Akhir} %TIDAK PERLU MENGUBAH BAGIAN INI !!!
	Pembimbing utama/tunggal: {\bf \pembA}\\
	Pembimbing pendamping: {\bf \pembB}\\
	Kode Topik : {\bf \kodetopik}\\
	Topik ini sudah dikerjakan selama : {\bf \lamaSkripsi} semester\\
	Pengambilan pertama kali topik ini pada : Semester {\bf \semesterPertama} \\
	Pengambilan pertama kali topik ini di kuliah : {\bf \kulPertama} \\
	Tipe Laporan : {\bf \tipePR} -
	\ifdefstring{\tipePR}{A}{
		Dokumen pendukung untuk {\BF pengambilan ke-2 di Tugas Akhir 1} }
	{
		\ifdefstring{\tipePR}{B} {
			Dokumen untuk reviewer pada presentasi dan {\bf review Tugas Akhir 1}}
		{	Dokumen pendukung untuk {\bf pengambilan ke-2 di Tugas Akhir 2}}
	}
	
	\section{Latar Belakang}
	Masalah n-queens merupakan salah satu permasalahan klasik dalam ilmu komputer yang telah dipelajari secara ekstensif sejak abad ke-19. \footnote{I.P. Gent, C. Jefferson, dan P. Nightingale, "Complexity of n-queens completion," \textit{Journal of Artificial Intelligence Research}, vol. 59, hal. 815--848, 2017.} Dalam bentuk standarnya, masalah n-queens memerlukan penempatan $n$ buah bidak menteri pada papan catur berukuran $n \times n$ sedemikian rupa sehingga tidak ada menteri yang dapat menyerang satu sama lain secara horizontal, vertikal, maupun diagonal seperti pada Gambar \ref{fig:NQ_wrong} dan \ref{fig:NQ_correct}. Sebagai contoh, pada papan berukuran $8 \times 8$, terdapat 92 solusi valid yang memenuhi seluruh kendala tersebut. Masalah ini tidak hanya menarik dari segi teoretis, tetapi juga memiliki aplikasi praktis dalam berbagai bidang seperti penjadwalan, alokasi sumber daya, dan desain sirkuit terpadu, sehingga menjadikannya salah satu tolok ukur penting dalam penelitian algoritma pencarian dan pemodelan berbasis kendala.
	
	\begin{figure}[H]
		\centering
		\begin{subfigure}{0.35\textwidth}
			\centering
			\includegraphics[width=\linewidth]{N_queens_wrong.png}
			\caption{Contoh solusi salah masalah N-Queens}
			\label{fig:NQ_wrong}
		\end{subfigure}
		\hspace{2cm}
		\begin{subfigure}{0.35\textwidth}
			\centering
			\includegraphics[width=\linewidth]{N_queens_correct.png}
			\caption{Contoh valid permasalahan N-Queens}
			\label{fig:NQ_correct}
		\end{subfigure}
		\caption{Perbandingan solusi N-Queens}
		\footnotesize Sumber: \url{https://www.researchgate.net/figure/N-Queen-problem-explanation-with-8-queens-in-a-chessboard-of-8_fig3_372415823}
		\label{fig:NQ_comparison}
	\end{figure}
	
	Seiring perkembangan penelitian, muncul berbagai variasi dari masalah n-queens tradisional yang menawarkan kompleksitas dan tantangan komputasional yang lebih tinggi. Salah satu variasi yang telah diteliti adalah \textit{N+k Queens Problem}, di mana $k$ buah bidak pion ditempatkan sebagai penghalang sehingga memungkinkan penempatan $N+k$ bidak menteri pada papan berukuran $N \times N$.\footnote{R.D. Chatham, "Reflections on the N+k Queens Problem," \textit{The College Mathematics Journal}, vol. 40, no. 3, hal. 204--210, Mei 2009.} Salah satu solusi dari \textit{8+1 Queens} dapat dilihat pada Gambar \ref{fig:nkSolution}.  Variasi lainnya adalah \textit{Toroidal N-Queens}, di mana papan catur dibentuk menjadi torus dengan menghubungkan sisi-sisi yang berlawanan, sehingga menteri dapat “melingkar” dari satu sisi ke sisi lainnya. \footnote{A. García Sánchez, "The n-Queens Problem: An Activity Book," Undergraduate Research Support Scheme, Mathematics Institute, University of Warwick, 2024. Supervised by Dr. Candida Bowtell.} Penyerangan yang dapat terjadi pada permasalahan \textit{Toroidal Queens} dapat dilihat pada Gambar \ref{fig:toroidalQueens}. Peningkatan kompleksitas pada variasi-variasi ini terlihat jelas; misalnya pada \textit{N+k Queens Problem} dengan $N=8$ dan $k=2$, jumlah kemungkinan konfigurasi yang harus dieksplorasi meningkat secara signifikan dibandingkan masalah standar karena adanya kendala tambahan berupa posisi pion yang tidak dapat dilanggar. Variasi-variasi ini menunjukkan bahwa menambahkan satu atau dua aturan baru saja dapat memperbesar ruang pencarian secara drastis dan mengubah struktur solusi masalah.
	
	\begin{figure}[H]
		\centering
		\begin{subfigure}{0.43\textwidth}
			\centering
			\includegraphics[width=\linewidth]{n+kSolution.png}
			\caption{ Contoh solusi salah masalah \textit{8+1 Queens}}
			\footnotesize Sumber: Penggambaran ulang dari \url{http://www.npluskqueens.info/background.html}
		\label{fig:nkSolution}
	\end{subfigure}
		\hspace{2cm}
		\begin{subfigure}{0.43\textwidth}
			\centering
			\includegraphics[width=\linewidth]{toroidalQueens.png}
			\caption{ Contoh penyerangan yang dapat terjadi pada masalah \textit{Toroidal Queens}}
			\footnotesize Sumber: Penggambaran ulang dari \url{https://www.johndcook.com/blog/2021/08/18/queens-on-a-donut/}
			\label{fig:toroidalQueens}
		\end{subfigure}
		\caption{Beberapa varian dari permaslahan \textit{N-Queens}}
		\label{fig:nqueenvariants}
	\end{figure}

	Tugas akhir ini berfokus pada varian \textit{Colored Queens}, sebuah permasalahan yang hingga saat ini memiliki literatur akademis dan penelitian secara formal dalam publikasi ilmiah yang minim. Berbeda dengan masalah n-queens tradisional, permainan \textit{Colored Queens} memiliki aturan yang lebih kompleks: papan permainan dibagi menjadi beberapa sektor berwarna seperti pada Gambar \ref{fig:Queens_unsolved_1}, setiap sektor harus berisi tepat satu bidak menteri, dan tidak ada menteri yang boleh bersebelahan secara langsung, baik horizontal, vertikal, maupun diagonal. Perbedaan fundamental lainnya adalah bahwa bidak menteri pada \textit{Colored Queens} hanya dapat menyerang secara horizontal dan vertikal, sehingga lebih dari satu bidak dapat ditempatkan pada satu garis diagonal yang sama, sehingga salah satu solusi valid untuk contoh permasalahan \textit{Colored Queens} dapat dilihat pada Gambar \ref{fig:Queens_solved_1}. Kompleksitas komputasional varian ini lebih tinggi dibandingkan permasalahan n-queens tradisional karena terdapat tiga lapis kendala yang harus dipenuhi secara simultan: kendala partisi warna (setiap warna tepat satu menteri), kendala \textit{adjacency} (tidak boleh bersebelahan), dan kendala serangan (horizontal dan vertikal). Sebagai ilustrasi, pada papan berukuran $6 \times 6$ dengan 6 sektor warna, ruang pencarian solusi menjadi jauh lebih sempit dan bergantung pada struktur pembagian sektor, sehingga kompleksitasnya umumnya lebih tinggi dibandingkan 6-queens standar yang memiliki ruang solusi yang lebih teratur. Ketidakteraturan struktur sektor warna juga membuat heuristik dan simetri yang biasa dimanfaatkan pada n-queens standar tidak lagi berlaku, sehingga \textit{Colored Queens} merupakan permasalahan yang jauh lebih sulit.

	\begin{figure}
		\centering
		\begin{subfigure}{0.3\textwidth}
			\centering
			\includegraphics[width=\linewidth]{Queens_unsolved.png}
			\caption{Contoh kondisi awal permainan Colored Queens}
			\label{fig:Queens_unsolved_1}
		\end{subfigure}
		\hspace{2cm}
		\begin{subfigure}{0.3\textwidth}
			\centering
			\includegraphics[width=\linewidth]{Queens_solved.png}
			\caption{Solusi valid permainan Colored Queens}
			\label{fig:Queens_solved_1}
		\end{subfigure}
		\caption{Contoh permainan \textit{Colored Queens}}
	\end{figure}
	
	Masalah n-queens dan seluruh variasinya, termasuk \textit{Colored Queens}, tergolong ke dalam kategori \textit{Constraint Satisfaction Problem} (CSP). CSP adalah jenis permasalahan yang melibatkan pencarian solusi dengan memberikan nilai pada sejumlah variabel sedemikian rupa sehingga memenuhi seperangkat batasan atau kendala tertentu. Secara formal, sebuah CSP didefinisikan oleh tiga komponen: himpunan variabel $X = \{X_1, X_2, ..., X_n\}$, himpunan domain $D = \{D_1, D_2, ..., D_n\}$ yang berisi nilai-nilai yang mungkin untuk setiap variabel, dan himpunan kendala C yang membatasi kombinasi nilai yang dapat diberikan pada variabel-variabel tersebut. Dalam konteks \textit{Colored Queens}, variabel-variabelnya adalah posisi menteri untuk setiap sektor warna, domain untuk setiap variabel adalah sel-sel yang tersedia pada sektor tersebut, dan kendala-kendalanya mencakup aturan tidak bersebelahan serta tidak saling menyerang, seperti yang tertera pada Gambar \ref{fig:4queensCSP_1}. CSP memiliki aplikasi luas dalam penjadwalan, perencanaan, konfigurasi produk, desain jaringan, serta berbagai sistem pengambilan keputusan berbasis kendala.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\linewidth]{4queensCSP.png}
		\caption{Contoh permasalahan \textit{4-Queens} yang dimodelkan sebagai CSP, dimana variabel X1 s.d. X4 adalah baris bidak menteri pada setiap kolomnya dengan nilai kemungkinan {1,2,3,4} dan kendala yang menghubungakn setiap variabel berupa aturan penyerangan bidak menteri pada permainan catur}
		\footnotesize Sumber: Penggambaran ulang dari \url{https://courses.grainger.illinois.edu/cs440/fa2021/lectures/csp1.html}
		\label{fig:4queensCSP_1}
	\end{figure}
	
	Untuk menyelesaikan permasalahan CSP seperti \textit{Colored Queens}, salah satu pendekatan klasik yang terbukti efektif adalah algoritma \textit{backtracking}. \textit{Backtracking} bekerja dengan membangun solusi secara bertahap melalui pencarian mendalam, di mana setiap variabel diberi nilai satu per satu sambil memeriksa konsistensi dengan kendala yang ada. Ketika algoritma menemui situasi di mana tidak ada nilai yang valid untuk variabel berikutnya (\textit{dead end}), algoritma akan mundur (\textit{backtrack}) ke langkah sebelumnya dan mencoba alternatif lain. Kekuatan \textit{backtracking} terletak pada sifatnya yang sistematis dan kemampuannya untuk menjamin bahwa solusi akan ditemukan jika memang ada. Namun, pada masalah dengan ruang pencarian yang berkembang secara eksponensial seperti \textit{Colored Queens}, \textit{backtracking} murni dapat menjadi sangat tidak efisien karena harus mengeksplorasi sejumlah besar kemungkinan konfigurasi sebelum menemukan solusi yang valid. Oleh karena itu, diperlukan modifikasi dan teknik tambahan untuk memangkas ruang pencarian agar algoritma tetap praktis digunakan pada instansi masalah \textit{Colored Queens} yang berukuran besar seperti papan $20 \times 20$ dan $30 \times 30$.
	
	Untuk meningkatkan efisiensi algoritma backtracking, tugas akhir ini mengintegrasikan teknik \textit{Maintaining Arc Consistency} (MAC) yang mengimplementasikan algoritma \textit{Arc Consistency 3} (AC-3). AC-3 adalah teknik propagasi kendala yang berfungsi untuk menyempitkan ruang pencarian dengan mengeliminasi nilai-nilai dalam domain yang tidak mungkin menghasilkan solusi valid berdasarkan kendala antarvariabel seperti yang dapat dilihat pada contoh Gambar \ref{fig:beforeafterARC}. Algoritma ini bekerja dengan memeriksa konsistensi antara pasangan variabel dan secara iteratif menghapus nilai-nilai yang tidak memiliki pasangan yang konsisten pada variabel lain. Dengan menjalankan AC-3 setiap kali backtracking membuat \textit{assignment} baru, banyak konfigurasi yang tidak valid dapat dieliminasi lebih awal sebelum algoritma membuang waktu mengeksplorasinya. Pada permasalahan seperti \textit{Colored Queens} yang memiliki ketergantungan antarvariabel sangat kuat akibat kendala \textit{adjacency} dan partisi warna, propagasi kendala memberikan dampak reduksi ruang solusi yang signifikan sehingga dapat mengurangi jumlah langkah \textit{backtracking} yang diperlukan secara drastis dan memperpendek waktu yang dibutuhkan untuk mencari solusi yang valid.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\linewidth]{beforeafterARC.png}
		\caption{Contoh ruang solusi \textit{4-Queens} yang dimodelkan sebagai CSP, sebelum(kiri) dan sesudah(kanan) menjalankan AC-3 pada saat menaruh bidak menteri di posisi 1 di kolom X1}
		\footnotesize Sumber: Diadaptasikan dari \url{https://courses.grainger.illinois.edu/cs440/fa2021/lectures/csp1.htm}
		\label{fig:beforeafterARC}
	\end{figure}
	
	Sebagai alternatif dari pendekatan deterministik, tugas akhir ini juga mengeksplorasi penggunaan \textit{Particle Swarm Optimization} (PSO), sebuah algoritma metaheuristik yang terinspirasi dari perilaku kolektif kawanan burung atau ikan dalam mencari makanan. Metaheuristik adalah strategi pencarian tingkat tinggi yang memandu proses eksplorasi ruang solusi tanpa menjamin menemukan solusi optimal, namun seringkali dapat menemukan solusi yang cukup baik dalam waktu yang lebih singkat dibandingkan metode eksak seperti backtracking. Gambar \ref{fig:PSOvisualization} menunjukkan bahwa PSO bekerja dengan mensimulasikan sekumpulan partikel yang bergerak dalam ruang solusi, di mana setiap partikel menyesuaikan posisinya berdasarkan pengalaman terbaiknya sendiri dan pengalaman terbaik kawanan. Kelebihan PSO terletak pada kemampuannya untuk melakukan eksplorasi ruang solusi secara paralel dan menghindari jebakan solusi lokal dalam beberapa kasus. Namun, karena PSO dirancang untuk ruang solusi kontinu, penerapannya pada \textit{Colored Queens} yang bersifat diskret memerlukan adaptasi khusus. Adaptasi tersebut mencakup representasi setiap partikel sebagai susunan posisi menteri untuk setiap sektor warna pada papan. Konsep velocity dalam PSO juga dimodifikasi menjadi bilangan desimal yang merepresentasikan probabilitas seberapa besar kemungkinan posisi menteri pada suatu sektor akan beralih mengikuti konfigurasi Neighbourhood Best, serta prosedur perbaikan (\textit{repair mechanisms}) untuk menangani solusi yang melanggar kendala hard constraint seperti aturan satu menteri per warna. Adaptasi ini penting agar PSO tetap relevan dan dapat memberikan performa yang kompetitif pada masalah bersifat kombinatorial.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\linewidth]{visualizationofPSO.png}
		\caption{Contoh pergerakan partikel-partikle ke arah solusi optimal dengan setiap iterasi}
		\footnotesize Sumber: Modifikasi dari \url{https://www.researchgate.net/figure/sualization-of-the-PSO-Algorithm_fig3_334363118}
		\label{fig:PSOvisualization}
	\end{figure}
	
	Dari segi pengembangan perangkat lunak, tugas akhir ini tidak hanya berfokus pada aspek algoritmik, tetapi juga pada penyediaan antarmuka pengguna untuk memainkan dan menyelesaikan berbagai contoh permasalahan \textit{Colored Queens} secara manual. Akan dikembangkan sebuah aplikasi berbasis web yang memungkinkan pengguna untuk berinteraksi langsung dengan permainan \textit{Colored Queens}, memilih tingkat kesulitan berdasarkan ukuran papan, serta memungkinkan pengguna untuk menyelesaikan \textit{puzzle} secara manual. Aplikasi ini akan dilengkapi sistem peringatan visual ketika pengguna menempatkan menteri pada posisi yang melanggar kendala, sehingga membantu pemahaman terhadap aturan permainan. Apabila kesulitan, pengguna dapat meminta bantuan berupa \textit{hint} untuk mempermudah proses penyelesaian \textit{puzzle}. Pengguna juga dapat memanggil \textit{solver} untuk menyelesaikan \textit{puzzle} secara otomatis apabila tidak bisa memecahkan masalah tersebut secara manual.

	
	\section{Rumusan Masalah}
	Sebelum masuk ke pembahasan lebih lanjut, berikut disajikan rumusan masalah yang menjadi dasar tugas akhir ini:
	\begin{itemize}	
		\item Bagaimana cara membangun perangkat lunak permainan \textit{Colored Queens}?
		\item Bagaimana membangun solusi permainan \textit{Colored Queens} menggunakan teknik \textit{Backtracking} dan \textit{Particle Swarm Optimization} (PSO)?
		\item Bagaimana membangun solver untuk permainan colored queen yang mengimplementasikan \textit{Backtracking} dan PSO yang dapat diintegrasikan dengan perangkat lunak yang dibangun?
		\item Bagiamana kinerja dari solver yang dibangun dalam mencari solusi permainan \textit{Colored Queens}?
	\end{itemize}
	
	\section{Tujuan}
	Selanjutnya, tujuan dari tugas akhir ini dapat dirumuskan sebagai berikut:
	\begin{itemize}	
		\item Membangun perangkat lunak permainan \textit{Colored Queens}.
		\item Mempelajari cara membangun solusi permainan Colored Queen menggunakan teknik \textit{Backtracking} dan \textit{Particle Swarm Optimization}.
		\item Membangun solver untuk permainan colored queen yang mengimplementasikan \textit{Backtracking} dan PSO yang dapat diintegrasikan dengan perangkat lunak yang dibangun.
		\item Melakukan pegujian untuk mengukur kinerja dari solver yang dibangun dalam mencari solusi permainan \textit{Colored Queens}
	\end{itemize}
	
	\section{Detail Perkembangan Pengerjaan Tugas Akhir}
	Detail bagian pekerjaan skripsi sesuai dengan rencana kerja/laporan perkembangan terkahir :
	\subsection{Melakukan studi literatur terkait permasalahan n-queens dan variannya.}
	{\bf Status :} Ada sejak rencana kerja skripsi.\\
	{\bf Hasil :} \\
	Permasalahan N-Queens merupakan salah satu permasalahan klasik dalam bidang ilmu komputer dan matematika diskrit, dengan sejarah panjang sejak pertama kali diperkenalkan oleh Max Bezzel pada tahun 1848. Pada formulasi dasar permasalahan ini, diberikan sebuah papan catur berukuran $n \times n$ dan tugasnya adalah menempatkan $n$ buah bidak menteri sedemikian rupa sehingga tidak ada dua menteri yang saling menyerang. Sebagaimana dalam aturan permainan catur, sebuah menteri dapat bergerak secara bebas dalam arah horizontal, vertikal, ataupun diagonal dengan jarak tak terbatas, sehingga setiap penempatan menteri harus mempertimbangkan seluruh arah serangan tersebut seperti yang tertera pada Gambar {\ref{fig:queenattackpattern}}.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\linewidth]{queen_attack_pattern.png}
		\caption{Contoh aturan penyerangan bidak menteri pada permainan catur. Silang merah menandakan kotak yang terserang oleh bidah menteri.}
		\label{fig:queenattackpattern}
	\end{figure}
	
	Dari perspektif komputasi, permasalahan ini menarik karena memiliki struktur yang sederhana namun ruang solusinya sangat besar dan tumbuh secara eksponensial. Jika setiap baris diasosiasikan dengan satu menteri, maka setiap menteri memiliki $n$ kemungkinan kolom, menghasilkan ruang solusi awal sebesar $n^n$. Ketika nilai $n$ meningkat, ruang solusi menjadi sangat luas sehingga pencarian solusi tanpa teknik penyempitan ruang menjadi tidak realistis. Sebagai contoh, untuk $n = 20$ saja terdapat $20^{20}$ kemungkinan konfigurasi awal, jumlah yang jauh melampaui kemampuan komputasi brute-force konvensional.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.35\linewidth]{N_queens_wrong.png}
		\caption{Contoh solusi salah masalah N-Queens pada papan berukuran $8 \times 8$ (8-Queens)}
		\footnotesize Sumber: \url{https://www.researchgate.net/figure/N-Queen-problem-explanation-with-8-queens-in-a-chessboard-of-8_fig3_372415823}
		\label{fig:nqueenswrong}
	\end{figure}
	
	Secara struktural, permasalahan N-Queens memiliki tiga komponen kendala utama yang harus dipenuhi secara simultan. Pertama, kendala kolom yang memastikan tidak ada dua menteri pada kolom yang sama. Kedua, kendala diagonal positif yang mencegah konflik pada diagonal dengan gradien positif. Ketiga, kendala diagonal negatif yang mencegah konflik pada diagonal dengan gradien negatif. Ketiga kendala ini membentuk sistem pembatasan yang saling berinteraksi, dan pelanggaran terhadap salah satu kendala mengakibatkan konfigurasi menjadi tidak valid. Pada contoh Gambar \ref{fig:nqueenswrong}, ketiga kendala dilanggar, sehingga menjadi salah satu solusi yang tidak valid untuk permasalahan N-Queens pada papan berukuran $8 \times 8$ (8-Queens). Interaksi kompleks antarkendala inilah yang membuat permasalahan ini dapat dimodelkan menggunakan kerangka kerja formal tertentu, yang akan dibahas lebih lanjut pada bagian berikutnya.
	
	Studi literatur juga menekankan bahwa meskipun solusi untuk N-Queens selalu ada untuk $n \geq 4$, struktur solusinya sangat beragam dan sering kali memiliki pola-pola tertentu yang dapat dimanfaatkan. Misalnya, penelitian yang dilakukan oleh Hoffman, Loessi, dan Moore\footnote{E. J. Hoffman, J. C. Loessi, and R. C. Moore, ``Constructions for the Solution of the m Queens Problem,'' \textit{Mathematics Magazine}, vol. 42, no. 2, hal. 66–72, 1969.} yang dikutip dalam survei komprehensif Bell dan Stevens\footnote{J. Bell and B. Stevens, ``A survey of known results and research areas for n-queens,'' \textit{Discrete Mathematics}, vol. 309, no. 1, hal. 1–31, 2009.} menjelaskan bahwa terdapat konstruksi aritmatika eksplisit yang dapat menghasilkan solusi dalam waktu linier $O(n)$ tanpa perlu melakukan eksplorasi ruang pencarian (\textit{search space}) sama sekali. Namun, pendekatan konstruktif deterministik semacam ini tidak berlaku secara umum untuk seluruh varian N-Queens—terutama yang memiliki kendala ireguler seperti pada \textit{Colored Queens}—sehingga algoritma pencarian tetap menjadi pendekatan yang paling banyak digunakan. Selain itu, jumlah solusi unik untuk N-Queens tumbuh secara eksponensial seiring bertambahnya $n$, dengan pola pertumbuhan yang telah menjadi objek kajian dalam teori kombinatorik.
	
	Secara keseluruhan, pemahaman mendalam mengenai sifat dasar N-Queens, karakteristik ruang pencariannya, struktur kendala yang mendasarinya, serta berbagai teknik algoritmik yang digunakan untuk menyelesaikannya memberikan landasan konseptual kuat sebelum mempelajari varian-varian yang lebih kompleks, termasuk Colored Queens yang menjadi fokus tugas akhir ini.
	
	\subsubsection{Berbagai Varian N-Queens}
	
	Berbagai penelitian telah mengembangkan sejumlah varian dari permasalahan N-Queens untuk mengeksplorasi karakteristik baru dalam struktur constraint, ruang solusi, maupun strategi penyelesaian. Varian-varian ini umumnya memodifikasi jumlah bidak, aturan serangan, atau bahkan topologi papan sehingga menghasilkan dinamika pencarian yang berbeda secara signifikan dari permasalahan N-Queens klasik. Pada bagian ini dibahas tiga varian yang relevan: \textit{N+k Queens}, \textit{Toroidal Queens}, dan \textit{Colored Queens}. Dua varian pertama merupakan topik yang telah diteliti secara formal dalam literatur akademik, sedangkan varian terakhir merupakan permasalahan non-standar yang tidak ditemukan dalam publikasi ilmiah dan menjadi fokus utama tugas akhir ini.
	
	\begin{enumerate}
	\item\textbf{Variasi \textit{N + k Queens}}\\
	Varian N+k Queens memodifikasi jumlah bidak menteri yang harus ditempatkan pada papan berukuran $n \times n$. Jika pada N-Queens standar terdapat tepat $n$ menteri, pada varian ini jumlah menteri menjadi $n + k$, di mana $k$ dapat bernilai positif maupun negatif. Untuk $k > 0$, algoritma harus menemukan konfigurasi dengan lebih dari $n$ menteri tanpa konflik horizontal, vertikal, maupun diagonal. Sebaliknya, ketika $k < 0$, tidak semua baris perlu diisi sehingga proses pencarian mencakup pemilihan subset baris yang digunakan.
	
	Struktur constraint pada N+k Queens lebih kompleks karena hubungan antara jumlah variabel dan domainnya tidak lagi linear seperti pada N-Queens standar. Penambahan jumlah menteri secara langsung meningkatkan densitas konflik, sehingga ruang pencarian menjadi lebih padat dan heuristik penyempitan domain menjadi jauh lebih penting. Varian ini sering digunakan untuk menguji ketahanan algoritma metaheuristik dan adaptasi CSP, sebab perubahan $k$ dapat menghasilkan tipe solusi yang berbeda, termasuk konfigurasi yang tidak mungkin muncul pada permasalahan dasar.
	
	\begin{figure}
		\centering
		\includegraphics[width=0.5\linewidth]{n+kSolution.png}
		\caption{Contoh solusi dari \textit{8+1 Queens} dimana terdapat 1 bidak pion pada posisi D5 mencegah penyerangan antara bidak menteri D4 dengan D6 dan B5 dengan G5.}
		\footnotesize Sumber: Penggambaran ulang dari \url{http://www.npluskqueens.info/background.html}
		\label{fig:solusi8+1Queens}
	\end{figure}
	
	\item\textbf{Variasi \textit{Toroidal Queens}}\\
	Varian toroidal mengubah struktur papan menjadi sebuah torus, di mana sisi kiri dan kanan papan terhubung, demikian pula sisi atas dan bawah. Perubahan topologi ini mengubah definisi serangan menteri karena pergerakannya bersifat \textit{wrap-around}: sebuah garis serangan tidak berhenti pada tepi papan tetapi terus berlanjut dari sisi berlawanan. Dengan demikian, konflik horizontal, vertikal, dan diagonal harus diperiksa dengan mempertimbangkan operasi modulo terhadap ukuran papan.
	
	Untuk memahami kompleksitas varian toroidal secara bertahap, dapat dipertimbangkan konsep \textit{semi-queen}, yaitu bidak imajiner yang dapat bergerak sepanjang baris, kolom, dan diagonal jumlah, tetapi tidak pada diagonal selisih. Analisis terhadap toroidal semi-queens menunjukkan bahwa solusi hanya ada ketika $n$ ganjil. \footnote{A. García Sánchez, "The n-Queens Problem: An Activity Book," Undergraduate Research Support Scheme, Mathematics Institute, University of Warwick, 2024. Supervised by Dr. Candida Bowtell.}
	
	Penelitian teoretis menunjukkan bahwa tidak semua ukuran papan memiliki solusi pada varian toroidal penuh. Hal ini berbeda jauh dari N-Queens standar yang memiliki solusi untuk semua $n \geq 4$. Dari perspektif CSP, varian toroidal menghasilkan grafik constraint yang lebih padat karena hubungan antarvariabel bersifat siklik, sehingga banyak teknik heuristik tradisional harus disesuaikan agar mempertimbangkan topologi torus. Studi varian ini memberikan wawasan mendalam mengenai bagaimana perubahan struktural pada ruang masalah dapat memengaruhi pola solusi dan kompleksitas komputasional.
	
	\begin{figure}
		\centering
		\includegraphics[width=0.5\linewidth]{toroidalQueens.png}
		\caption{Ilustrasi serangan menteri pada papan toroidal. Garis merah menunjukkan serangan yang melewati batas papan dan berlanjut dari sisi berlawanan (\textit{wrap-around}). Menteri yang dilingkari merah menyerang menteri lain melalui koneksi toroidal.}
		\footnotesize Sumber: Penggambaran ulang dari \url{https://www.johndcook.com/blog/2021/08/18/queens-on-a-donut/}
		\label{fig:4queensCSP}
	\end{figure}
	
	\item\textbf{Variasi \textit{Colored Queens}}\\
	Berbeda dengan dua varian sebelumnya, \textit{Colored Queens} merupakan varian non-standar yang tidak ditemukan dalam literatur akademik formal. Hingga saat penulisan laporan ini, tidak terdapat publikasi ilmiah—baik jurnal maupun prosiding—yang membahas permasalahan Colored Queens secara eksplisit. Permasalahan ini muncul dalam konteks permainan logika komersial berbasis teka-teki, bukan dalam riset teoretis N-Queens. Oleh karena itu, struktur formal, representasi CSP, serta analisis algoritmik untuk varian ini harus dikonstruksi sendiri sebagai bagian dari penelitian.
	
	Pada varian Colored Queens, papan permainan dibagi ke dalam sejumlah kawasan atau sektor yang masing-masing diberi warna berbeda. Setiap sektor harus berisi tepat satu menteri, sehingga constraint warna menjadi komponen tambahan selain constraint klasik (baris, kolom, dan—pada Colored Queens—hanya sebagian aspek diagonal). Salah satu perbedaan paling signifikan dari N-Queens tradisional adalah bahwa pada Colored Queens, menteri tidak menyerang secara diagonal, melainkan hanya secara horizontal dan vertikal. Akibatnya, lebih dari satu menteri dapat berada dalam satu diagonal tanpa menyebabkan konflik, berbeda dengan aturan standar catur. Namun, varian ini menambahkan aturan baru berupa larangan menempatkan dua menteri pada sel yang saling bersebelahan baik secara horizontal, vertikal, maupun diagonal. Hal ini menjadikan struktur constraint unik: sebagian diagonal diabaikan (untuk serangan), tetapi sebagian diagonal diperhitungkan (untuk adjacency constraint).
	
	Dibandingkan varian-varian formal lainnya, Colored Queens memiliki dua karakteristik yang membuatnya menarik untuk dikaji sebagai CSP dan sebagai objek analisis algoritmik:
	\begin{enumerate}
		\item \textit{Constraint warna} menjadikan setiap sektor bertindak sebagai variabel tingkat tinggi dengan domain yang harus memastikan pemilihan tepat satu sel dalam area tertentu.
		\item \textit{Aturan adjacency} menciptakan constraint jarak pendek yang meningkatkan kepadatan konflik lokal, namun tidak mempengaruhi konflik jarak jauh seperti pada N-Queens standar.
	\end{enumerate}
	
	Sifat-sifat ini menjadikan Colored Queens sebagai permasalahan yang secara struktural berbeda dari varian N-Queens mana pun dalam literatur. Akibat ketiadaan referensi formal, tugas akhir ini perlu menyusun sendiri definisi matematis, model CSP, serta strategi algoritmik berbasis Backtracking dengan AC-3 dan Particle Swarm Optimization untuk memecahkan permasalahan tersebut. Dengan demikian, studi Colored Queens tidak hanya mengimplementasikan algoritma, tetapi juga berkontribusi dalam formalisasi permasalahan baru, pembangunan model CSP yang sesuai, dan analisis komparatif strategi algoritmik berbasis Backtracking dengan AC-3 dan Particle Swarm Optimization pada domain yang belum pernah dikaji secara akademik sebelumnya.
	
		\begin{figure}
			\centering
			\begin{subfigure}{0.35\textwidth}
				\centering
				\includegraphics[width=\linewidth]{Queens_unsolved.png}
				\caption{Contoh kondisi awal permainan Colored Queens}
				\label{fig:Queens_unsolved}
			\end{subfigure}
			\hspace{2cm}
			\begin{subfigure}{0.35\textwidth}
				\centering
				\includegraphics[width=\linewidth]{Queens_solved.png}
				\caption{Solusi valid permainan Colored Queens}
				\label{fig:Queens_solved}
			\end{subfigure}
			\caption{Contoh permainan Colored Queens}
			\label{fig:permainanCQ}
		\end{figure}
	\end{enumerate}
	
	\subsection{Melakukan studi literatur terkait Constraint Satisfaction Problem (CSP).}
	{\bf Status :} Ada sejak rencana kerja skripsi.\\
	{\bf Hasil :}\\
	\textit{Constraint Satisfaction Problem} (CSP) adalah kerangka kerja umum untuk merepresentasikan dan menyelesaikan berbagai permasalahan kombinatorial. Secara formal, CSP terdiri dari tiga komponen utama: (1) sekumpulan variabel $X = \{X_1, \ldots, X_n\}$, (2) untuk setiap variabel $X_i$, sebuah himpunan domain $D_i$ yang berisi nilai-nilai yang mungkin dapat diberikan kepada variabel tersebut, dan (3) sekumpulan \textit{constraint} atau batasan yang membatasi kombinasi nilai yang dapat diberikan kepada variabel-variabel secara bersamaan.\footnote{S.C. Brailsford, C.N. Potts, dan B.M. Smith, "Constraint satisfaction problems: Algorithms and applications," \textit{European Journal of Operational Research}, vol. 119, no. 3, hal. 557-581, 1999.} Solusi dari CSP adalah pemberian nilai kepada setiap variabel dari domain masing-masing sedemikian rupa sehingga semua batasan terpenuhi.
	
	Keunggulan pendekatan CSP terletak pada fleksibilitasnya dalam menangani berbagai jenis batasan, tidak terbatas pada batasan linear seperti dalam \textit{integer programming}. Algoritma penyelesaian CSP umumnya menggunakan pencarian pohon yang dikombinasikan dengan teknik \textit{backtracking} dan \textit{consistency checking}, di mana pemberian nilai pada satu variabel dapat memicu propagasi batasan yang mengurangi domain variabel-variabel lainnya, sehingga mempercepat pencarian solusi.
	
	Klasifikasi \textit{constraint} dalam CSP umumnya dibedakan berdasarkan aritas atau jumlah variabel yang terlibat dalam batasan tersebut. Batasan paling sederhana adalah \textit{unary constraint} yang membatasi nilai domain variabel tunggal. Batasan yang melibatkan dua variabel disebut \textit{binary constraint} dan sering direpresentasikan sebagai sisi (\textit{edge}) dalam graf kendala (\textit{constraint graph}). Selain itu, terdapat \textit{global constraint} yang melibatkan jumlah variabel arbitrer, seperti \textit{Alldifferent}, yang mengharuskan semua variabel dalam himpunan tertentu memiliki nilai yang berbeda.\footnote{F. Rossi, P. van Beek, dan T. Walsh, \textit{Handbook of Constraint Programming}, Elsevier, 2006, hal. 13-15.} Penggunaan \textit{global constraint} memungkinkan algoritma penyelesaian untuk melakukan pemangkasan (\textit{pruning}) ruang pencarian secara lebih efisien dibandingkan dengan hanya menggunakan sekumpulan \textit{binary constraint}.
	
	Salah satu konsep fundamental dalam reduksi ruang pencarian CSP adalah konsistensi lokal, khususnya \textit{Arc Consistency}. Sebuah variabel $X_i$ dikatakan \textit{arc-consistent} terhadap variabel $X_j$ jika untuk setiap nilai dalam domain $D_i$, terdapat setidaknya satu nilai dalam domain $D_j$ yang memenuhi batasan biner antara keduanya. Algoritma seperti AC-3 bekerja dengan menegakkan properti ini secara iteratif; jika suatu nilai dalam $D_i$ tidak memiliki dukungan (\textit{support}) di $D_j$, maka nilai tersebut dihapus dari domain.\footnote{A. K. Mackworth, "Consistency in networks of relations," \textit{Artificial Intelligence}, vol. 8, no. 1, hal. 99-118, 1977.} Proses ini mencegah algoritma pencarian mengeksplorasi cabang pohon yang sudah pasti akan gagal, sehingga mengurangi upaya komputasi secara signifikan.
	
	Selain propagasi batasan, efisiensi penyelesaian CSP juga sangat bergantung pada urutan instansiasi variabel dan pemilihan nilai. Heuristik \textit{Variable Ordering} yang umum digunakan adalah \textit{Minimum Remaining Values} (MRV), yang memprioritaskan variabel dengan domain terkecil untuk dievaluasi lebih awal guna mendeteksi kegagalan secepat mungkin (\textit{fail-first principle}). Sebaliknya, untuk pemilihan nilai, heuristik \textit{Least Constraining Value} (LCV) sering diterapkan dengan memilih nilai yang paling sedikit membatasi pilihan variabel lain di masa depan, dengan tujuan menemukan solusi valid lebih cepat.\footnote{R. M. Haralick dan G. L. Elliott, "Increasing tree search efficiency for constraint satisfaction problems," \textit{Artificial Intelligence}, vol. 14, no. 3, hal. 263-313, 1980.}
	
	\subsection{Melakukan studi literatur terkait algoritma pencarian Backtracking.}
	{\bf Status :} Ada sejak rencana kerja skripsi.\\
	{\bf Hasil :}\\
	Algoritma backtracking merupakan salah satu dari tiga teknik algoritma utama untuk menyelesaikan CSP, bersama dengan \textit{local search} dan \textit{dynamic programming}.\footnote{P. van Beek, ``Backtracking Search Algorithms,'' dalam \textit{Handbook of Constraint Programming}, F. Rossi, P. van Beek, dan T. Walsh, Ed., Elsevier, 2006, hal. 85--133.} Algoritma backtracking tergolong sebagai algoritma \textit{complete} atau sistematis, yang berarti algoritma ini dijamin menemukan solusi jika solusi tersebut ada, dan dapat membuktikan bahwa suatu CSP tidak memiliki solusi. Berbeda dengan dynamic programming yang memerlukan waktu dan ruang eksponensial serta menemukan semua solusi sekaligus, algoritma backtracking bekerja pada satu solusi dalam satu waktu sehingga hanya memerlukan ruang polinomial. Prinsip dasar backtracking adalah melakukan penelusuran depth-first pada pohon pencarian, di mana pohon pencarian dihasilkan secara bertahap selama pencarian berlangsung dan merepresentasikan pilihan-pilihan alternatif yang mungkin perlu diperiksa untuk menemukan solusi.
	
	Mekanisme fundamental yang membedakan backtracking dari pencarian \textit{brute-force} murni adalah penerapan fungsi pembatas (\textit{bounding function}) untuk memangkas ruang pencarian. Dalam terminologi pohon ruang status (\textit{state space tree}), setiap simpul yang dikunjungi dievaluasi apakah "menjanjikan" (\textit{promising}) atau tidak. Sebuah simpul dikatakan menjanjikan jika simpul tersebut dapat mengarah pada solusi parsial yang valid dengan memenuhi semua batasan yang ada saat ini. Sebaliknya, jika sebuah simpul melanggar batasan, simpul tersebut dinyatakan \textit{non-promising} atau "mati". Konsep pemangkasan simpul yang tidak menjanjikan ini diilustrasikan pada Gambar \ref{fig:backtracking_pruning}.
	
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.7\textwidth]{gambar/cspPruning.png} 
		\caption{Visualisasi pohon ruang status (\textit{State Space Tree}) untuk masalah 4-Queens. Simpul yang melanggar batasan (bertanda silang merah) diidentifikasi sebagai \textit{non-promising} dan dipangkas (\textit{pruned}), sehingga algoritma tidak perlu mengeksplorasi cabang di bawahnya.}
		\label{fig:backtracking_pruning}
	\end{figure}
	
	Ketika algoritma menemukan simpul yang tidak menjanjikan, algoritma tidak akan melanjutkan eksplorasi ke anak-anak simpul tersebut (\textit{pruning} atau pemangkasan sub-pohon), melainkan segera melakukan langkah mundur (\textit{backtrack}) ke simpul induk untuk mencoba alternatif nilai lain.\footnote{A. Levitin, \textit{Introduction to the Design and Analysis of Algorithms}, 3rd ed., Pearson Education, 2012, hal. 423.} Strategi ini memungkinkan algoritma menghindari eksplorasi jutaan status yang tidak relevan, yang secara signifikan mengurangi waktu komputasi dibandingkan dengan metode pembangkitan dan pengujian (\textit{generate-and-test}) yang naif.
	
	Meskipun backtracking standar menjamin ditemukannya solusi yang valid, kinerjanya sangat bergantung pada ukuran domain dan urutan penugasan variabel. Oleh karena itu, dalam aplikasi CSP modern, backtracking jarang digunakan dalam bentuk murninya (\textit{naive backtracking}). Algoritma ini umumnya ditingkatkan dengan teknik "look-ahead" seperti \textit{Forward Checking} atau \textit{Maintaining Arc Consistency} (MAC), yang bertujuan untuk mendeteksi jalan buntu (\textit{dead-end}) lebih awal dengan menyaring domain variabel masa depan setiap kali sebuah keputusan dibuat.\footnote{S. Russell dan P. Norvig, \textit{Artificial Intelligence: A Modern Approach}, 4th ed., Pearson, 2020, hal. 215--217.}
	
	\subsection{Melakukan studi literatur terkait \textit{teknik metaheuristik Particle Swarm Optimization}.}
	{\bf Status :} Ada sejak rencana kerja skripsi.\\
	{\bf Hasil :}\\
	\textit{Particle Swarm Optimization} (PSO) adalah algoritma optimasi berbasis populasi yang diperkenalkan oleh Kennedy dan Eberhart pada tahun 1995.\footnote{J. Kennedy and R. Eberhart, "Particle swarm optimization," \textit{Proceedings of IEEE International Conference on Neural Networks}, Perth, Australia, pp. 1942-1948, 1995.} Algoritma ini terinspirasi dari perilaku sosial kawanan burung (\textit{bird flocking}) atau gerombolan ikan (\textit{fish schooling}) dalam mencari sumber makanan. Dalam alam, ketika seekor burung menemukan jalur yang efisien menuju makanan, anggota kawanan lainnya dengan cepat menyesuaikan jalur mereka untuk mengikutinya, terlepas dari posisi awal mereka dalam kelompok.\footnote{Okto Suprianto, Mariatul Kiftiah, dan Hendra Perdana, "Penerapan Particle Swarm Optimization dalam Penyusunan Jadwal Mata Kuliah di Prodi Matematika Universitas Tanjungpura," \textit{Bimaster: Buletin Ilmiah Matematika, Statistika dan Terapannya}, Volume 13, No 05, hal 609-618, 2024.}
	
	\textbf{Konsep Dasar PSO}
	
	Dalam PSO, setiap solusi potensial disebut sebagai \textit{particle} (partikel), dan kumpulan dari partikel-partikel tersebut disebut \textit{swarm} (kawanan). Setiap partikel bernavigasi melalui ruang solusi dengan kecepatan (\textit{velocity}) yang disesuaikan berdasarkan pengalaman mereka sendiri dan pengalaman kawanan secara keseluruhan. Algoritma PSO dimulai dengan populasi acak yang disebut partikel, dan setiap partikel "terbang" melalui ruang masalah dengan mengikuti partikel-partikel yang berkinerja lebih baik.\footnote{Xiaohui Hu, Russell C. Eberhart, dan Yuhui Shi, "Swarm Intelligence for Permutation Optimization: A Case Study of n-Queens Problem," \textit{Proceedings of IEEE Swarm Intelligence Symposium}, pp. 243-246, 2003.}
	
	Setiap partikel memiliki dua atribut utama:
	\begin{enumerate}
		\item \textbf{Posisi} ($X_i$): merepresentasikan solusi kandidat dalam ruang pencarian
		\item \textbf{Velocity} ($V_i$): menentukan arah dan jarak perpindahan partikel
	\end{enumerate}
	
	\begin{figure}
		\centering
		\includegraphics[width=0.6\linewidth]{pso_single.png}
		\caption{Ilustrasi perpindahan satu partikel berdaskarkan \textit{Velocity} baru yang dipengaruhi oleh \textit{personal best} dan \textit{global best}}
		\footnotesize Sumber: \url{https://www.baeldung.com/cs/pso}
		\label{fig:singlepso}
	\end{figure}
	
	Selain itu, setiap partikel melacak dua nilai penting:
	\begin{itemize}
		\item \textbf{Personal Best} (\textit{pBest}): posisi terbaik yang pernah dicapai oleh partikel tersebut selama proses pencarian
		\item \textbf{Global Best} (\textit{gBest}) atau \textbf{Neighborhood Best} (\textit{nBest}): posisi terbaik yang dicapai oleh seluruh kawanan (global) atau oleh tetangga-tetangga terdekat (lokal)
	\end{itemize}
	
	\textbf{Persamaan Update PSO}
	
	Pada setiap iterasi, velocity dan posisi setiap partikel diperbarui menggunakan persamaan berikut:
	
	\begin{equation}
		V_i^{k+1} = \omega \cdot V_i^k + c_1 \cdot r_1 \cdot (pBest_i - X_i^k) + c_2 \cdot r_2 \cdot (gBest - X_i^k)
		\label{eq:velocity}
	\end{equation}
	
	\begin{equation}
		X_i^{k+1} = X_i^k + V_i^{k+1}
		\label{eq:position}
	\end{equation}
	
	di mana:
	\begin{itemize}
		\item $V_i^k$ adalah velocity partikel $i$ pada iterasi ke-$k$
		\item $X_i^k$ adalah posisi partikel $i$ pada iterasi ke-$k$
		\item $\omega$ adalah \textit{inertia weight} yang mengontrol momentum partikel (biasanya 0.7-0.9)
		\item $c_1$ adalah \textit{cognitive coefficient} yang mengontrol pengaruh \textit{personal best} (biasanya 1.5-2.0)
		\item $c_2$ adalah \textit{social coefficient} yang mengontrol pengaruh \textit{global best} (biasanya 1.5-2.0)
		\item $r_1, r_2$ adalah bilangan acak dalam rentang [0,1]
	\end{itemize}
	
	Secara konseptual, persamaan (\ref{eq:velocity}) menggabungkan tiga komponen pergerakan yang diilustrasikan pada Gambar \ref{fig:singlepso}:
	\begin{enumerate}
		\item \textbf{Komponen Inersia} ($\omega \cdot V_i^k$): Kecenderungan partikel untuk terus bergerak ke arah yang sama dengan langkah sebelumnya (digambarkan sebagai vektor $v_i$).
		\item \textbf{Komponen Kognitif} ($c_1 \cdot r_1 \cdot (pBest_i - X_i^k)$): Kecenderungan partikel untuk kembali ke posisi terbaik yang pernah ia temukan sendiri (vektor putus-putus menuju $pbest_i$).
		\item \textbf{Komponen Sosial} ($c_2 \cdot r_2 \cdot (gBest - X_i^k)$): Kecenderungan partikel untuk bergerak menuju posisi terbaik yang ditemukan oleh kawanan/kelompok (vektor putus-putus menuju $gbest$).
	\end{enumerate}
	Interaksi ketiga vektor gaya inilah yang menghasilkan posisi baru (lingkaran oranye pada gambar) yang diharapkan lebih dekat dengan solusi optimal.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.45\linewidth]{psoflow.png}
		\caption{Diagram alir PSO yang menggambarkan inisialisasi partikel, pembaruan \textit{velocity} dan posisi, evaluasi fitness, serta mekanisme pembaruan pBest dan gBest.}
		\footnotesize Sumber: Terjemahan dan penggambaran ulang dari \url{https://www.elsevier.es/en-revista-journal-applied-research-technology-jart-81-articulo-a-pso-procedure-for-coordinated-S1665642313715748}
		\label{fig:psoflow}
	\end{figure}
	
	\textbf{Langkah-langkah algoritma PSO (mengacu pada diagram alir \ref{fig:psoflow})}
	\begin{enumerate}
		\item \textbf{Inisialisasi parameter} \\
		Tentukan nilai-nilai untuk ukuran populasi $N$, inertia $\omega$, konstanta $c_1$ dan $c_2$, serta kriteria penghentian (mis. jumlah iterasi maksimum atau toleransi perubahan fitness).
		\item \textbf{Beri nilai acak awal untuk posisi dan kecepatan setiap partikel.} Untuk setiap partikel $i=1\ldots N$, inisialisasi $X_i^0$ (mis. di ruang solusi) dan $V_i^0$ (mis. kecil dan acak).
		\item \textbf{Inisialisasi $pBest$ dan $gBest$.} Hitung fitness pada posisi awal tiap partikel. Set $pBest_i = X_i^0$ untuk setiap partikel. Tentukan $gBest$ sebagai posisi dengan nilai fitness terbaik di antara semua $pBest_i$.
		\item \textbf{Perulangan hingga memenuhi \textit{stopping condition}:}
		\begin{enumerate}
			\item \textbf{Hitung velocity baru setiap partikel} \\
			Untuk tiap partikel $i$, hitung $V_i^{k+1}$ sesuai persamaan (\ref{eq:velocity}).
			\item \textbf{Hitung posisi baru setiap partikel} \\
			Untuk tiap partikel $i$, perbarui posisi menggunakan persamaan (\ref{eq:position})
			\item \textbf{Evaluasi fitness setiap partikel.} \\
			Hitung nilai fungsi objektif pada $X_i^{k+1}$ untuk tiap partikel.
			\item \textbf{Perbarui $pBest$ dan $gBest$ jika ada perbaikan.} \\
			Jika fitness($X_i^{k+1}$) lebih baik daripada \textit{fitness}($pBest_i$), maka $pBest_i = X_i^{k+1}$. Jika ada $pBest_i$ yang lebih baik daripada fitness($gBest$), maka $gBest = pBest_i$.
			\item \textbf{Cek \textit{stopping condition}.} \\
			Jika kondisi penghentian tercapai, bisa dalam bentuk jumlah iterasi maksimum atau tidak ada peningkatan kualitas solusi yang signifikan, keluarkan hasil; jika belum, lanjutkan ke iterasi berikutnya dan kembali ke langkah menghitung \textit{velocity}.
		\end{enumerate}
		\item \textbf{Keluaran} Berikan posisi partikel dengan nilai fitness terbaik yaitu $gBest$ sebagai solusi akhir.
	\end{enumerate}
	
	
	\textbf{Keunggulan PSO}
	
	PSO memiliki beberapa keunggulan yang menjadikannya populer di kalangan peneliti dan praktisi:
	
	\begin{enumerate}
		\item \textbf{Kesederhanaan implementasi}: PSO memiliki struktur algoritma yang sederhana dengan parameter yang sedikit, sehingga mudah dipahami dan diimplementasikan.\footnote{N. K. Jain, Uma Nangia, dan Jyoti Jain, "A Review of Particle Swarm Optimization," \textit{Journal of The Institution of Engineers (India): Series B}, 2018.} Tidak seperti Genetic Algorithm (GA), PSO tidak memerlukan operator evolusi seperti \textit{crossover} dan \textit{mutation}.
		
		\item \textbf{Konvergensi cepat}: PSO cenderung konvergen lebih cepat dibandingkan algoritma evolusioner lainnya, terutama pada tahap awal pencarian. Hal ini karena informasi \textit{global best} langsung dibagikan ke seluruh partikel dalam kawanan.
		
		\item \textbf{Fleksibilitas}: PSO dapat disesuaikan untuk berbagai jenis masalah optimasi, baik kontinu maupun diskret, tanpa perubahan mendasar pada struktur algoritma.
		
		\item \textbf{Keseimbangan eksplorasi-eksploitasi}: Melalui parameter $\omega$, $c_1$, dan $c_2$, PSO dapat menyeimbangkan antara eksplorasi (pencarian area baru) dan eksploitasi (pencarian intensif di area yang menjanjikan).
		
		\item \textbf{Paralelisasi mudah}: Karena setiap partikel dapat dievaluasi secara independen, PSO sangat cocok untuk implementasi paralel, yang dapat mempercepat proses komputasi secara signifikan.
	\end{enumerate}
	
	Keberhasilan PSO di berbagai domain telah memicu banyak penelitian untuk memodifikasi dan meningkatkan performanya, seperti penambahan mutasi, hibridisasi dengan algoritma lain, dan adaptasi untuk masalah multiobjektif atau masalah diskret kombinatorika.\footnote{Y. Zhang, S. Wang, dan G. Ji, "A comprehensive survey on particle swarm optimization algorithm and its applications," \textit{Mathematical Problems in Engineering}, 2015.}
	
	\subsection{Melakukan studi literatur terkait metode propagasi kendala \textit{Maintaining Arc Consistency} (MAC), terutama algoritma \textit{Arc Consistency 3} (AC-3).}
	{\bf Status :} Ada sejak rencana kerja skripsi.\\
	{\bf Hasil :}\\
	\textit{Maintaining Arc Consistency} (MAC) adalah teknik propagasi constraint yang digunakan selama proses pencarian solusi dalam \textit{Constraint Satisfaction Problem} (CSP). Untuk memahami MAC, pertama-tama kita perlu memahami konsep \textit{arc} dalam CSP.
	
	\textbf{Arc dalam CSP:} Dalam jaringan constraint biner yang ternormalisasi, sebuah \textit{arc} adalah pasangan terurut $(x_i, c_{ij})$ yang menunjukkan bahwa variabel $x_i$ harus konsisten dengan constraint $c_{ij}$ yang menghubungkan $x_i$ dengan variabel lain $x_j$.\footnote{Bessiere, C. (2006). Constraint Propagation. \textit{Handbook of Constraint Programming}, hal. 39.} Sebuah nilai $v_i \in D(x_i)$ dikatakan konsisten dengan constraint $c_{ij}$ jika terdapat setidaknya satu nilai $v_j \in D(x_j)$ sedemikian sehingga pasangan $(v_i, v_j)$ memenuhi constraint $c_{ij}$. Nilai $v_j$ ini disebut sebagai \textit{support} untuk $v_i$ pada constraint $c_{ij}$.
	
	\textbf{Peran MAC:} MAC bekerja dengan menjaga \textit{arc consistency} setelah setiap assignment variabel selama pencarian solusi.\footnote{Thorisson, H. (2017). Arc Consistency and Domain Splitting. Tersedia di: https://www.youtube.com/watch?v=4cCS8rrYT14} Ketika sebuah variabel diberi nilai, MAC akan melakukan propagasi untuk menghilangkan nilai-nilai yang tidak konsisten dari domain variabel-variabel lain yang terhubung. Hal ini membantu mendeteksi inkonsistensi lebih awal dalam proses pencarian dan mengurangi ruang pencarian secara signifikan.
	
	\textbf{Algoritma AC-3:} AC-3 adalah algoritma yang paling terkenal untuk menegakkan \textit{arc consistency}.\footnote{Bessiere, C. (2006). Constraint Propagation. \textit{Handbook of Constraint Programming}, hal. 38-40.} Algoritma ini menggunakan pendekatan berbasis antrian (\textit{queue}) untuk memproses arc yang perlu direvisi. Berikut adalah pseudocode algoritma AC-3:
	
	\begin{lstlisting}[language=Python, caption={Algoritma AC-3}, mathescape=true]
	function AC3(X: set): Boolean;
	begin
	/* inisialisasi */
	Q $\leftarrow$ {$(x_i, c)$ | $c \in C$, $x_i \in X(c)$};
	
	/* propagasi */
	while Q $\neq \emptyset$ do
	pilih dan hapus $(x_i, c)$ dari Q;
	if Revise($x_i$, c) then
	if $D(x_i) = \emptyset$ then return false;
	else Q $\leftarrow$ Q $\cup$ {$(x_j, c')$ | $c' \in C$ $\wedge$ 
		$c' \neq c$ $\wedge$ $x_i, x_j \in X(c')$ $\wedge$ $j \neq i$};
	return true;
	end
	
	function Revise($x_i$: variable; c: constraint): Boolean;
	begin
	CHANGE $\leftarrow$ false;
	foreach $v_i \in D(x_i)$ do
	if $\nexists \tau \in c \cap \pi_{X(c)}(D)$ with $\tau[x_i] = v_i$ then
	hapus $v_i$ dari $D(x_i)$;
	CHANGE $\leftarrow$ true;
	return CHANGE;
	end
	\end{lstlisting}
	
	\textbf{Penjelasan notasi dan cara kerja:}
	\begin{itemize}
	\item $X$: himpunan semua variabel dalam CSP
	\item $D(x_i)$: domain dari variabel $x_i$, yaitu himpunan nilai-nilai yang mungkin untuk $x_i$
	\item $c$: sebuah constraint dalam jaringan
	\item $X(c)$: skema constraint $c$, yaitu urutan variabel yang terlibat dalam constraint $c$
	\item $Q$: antrian yang berisi pasangan $(x_i, c)$ yang perlu direvisi
	\item $\pi_{X(c)}(D)$: proyeksi domain $D$ pada variabel-variabel dalam $X(c)$
	\item $\tau[x_i]$: nilai yang diberikan pada variabel $x_i$ dalam tuple $\tau$
	\end{itemize}
	
	Algoritma dimulai dengan memasukkan semua pasangan $(x_i, c)$ ke dalam antrian $Q$ (baris 3). Kemudian, selama $Q$ tidak kosong, algoritma mengambil sebuah pasangan $(x_i, c)$ dan memanggil fungsi \texttt{Revise} untuk memeriksa apakah setiap nilai dalam $D(x_i)$ memiliki \textit{support} pada constraint $c$ (baris 6-7). Fungsi \texttt{Revise} mengembalikan \texttt{true} jika ada nilai yang dihapus dari $D(x_i)$.
	
	Jika domain $D(x_i)$ menjadi kosong setelah revisi, algoritma mengembalikan \texttt{false} yang menandakan bahwa tidak ada solusi (baris 8). Jika ada nilai yang dihapus tetapi domain tidak kosong, maka semua arc $(x_j, c')$ yang melibatkan $x_i$ ditambahkan kembali ke $Q$ karena perubahan pada $D(x_i)$ mungkin mempengaruhi konsistensi variabel lain (baris 9). Algoritma berakhir dan mengembalikan \texttt{true} ketika $Q$ kosong, yang berarti semua arc telah konsisten.
	
	\subsection{Mengumpulkan dan menyusun berbagai skenario permasalahan Colored Queens yang akan digunakan sebagai basis pengujian algoritma serta sebagai pilihan tingkat kesulitan bagi pengguna.}
	{\bf Status :} Ada sejak rencana kerja skripsi.\\
	{\bf Hasil :}\\
	Sebagai bagian dari tahap pengumpulan dan penyusunan skenario permasalahan Colored Queens, saya membangun sebuah web scraper Python yang menggunakan library Selenium, seperti pada listing \ref{lst:fullscraper},  untuk mengekstraksi beragam konfigurasi papan dari situs \textbf{\textit{Play Queens Game}}.\footnote{Situs daring dapat diakses melalui \url{https://www.playqueensgame.com/}} Data ini diperlukan sebagai dasar pengujian untuk algoritma Backtracking dan Particle Swarm Optimization (PSO), sekaligus menjadi kumpulan level yang dapat dipilih pengguna berdasarkan tingkat kesulitan. Skrip yang dibuat mengotomatisasi proses pengambilan puzzle untuk berbagai ukuran papan—mulai dari 7×7 hingga 11×11—dengan jumlah level yang bervariasi pada setiap ukuran. Setiap puzzle diakses melalui URL tertentu, kemudian Selenium membaca atribut setiap sel (baris, kolom, dan warna) untuk membentuk representasi papan yang terstruktur. Inti dari \textit{web scraper} ini, yang dapat dilihat pada potongan kode listing \ref{lst:scraperinti}, adalah pengambilan data sel papan permainan dengan menargetkan elemen HTML \texttt{<div>} yang memiliki atribut kustom \texttt{data-row} dan \texttt{data-col}, lalu mengekstraksi koordinat serta nilai warna RGB dari properti CSS \texttt{background-color}. 
	
	Listing \ref{lst:jsonSample} merupakan cuplikan dari hasil ekstraksi disimpan dalam bentuk berkas JSON yang menyimpan posisi baris, kolom, serta warna dari setiap kotak di dalam papan, agar mudah diproses kembali oleh \textit{solver} maupun antarmuka pengguna. Pendekatan ini memastikan bahwa dataset berisi skenario yang beragam, valid, dan sesuai dengan mekanisme permainan asli. Dengan adanya kumpulan skenario ini, pengujian algoritma dapat dilakukan pada berbagai tingkat kesulitan, dan pengguna aplikasi dapat memilih puzzle berdasarkan ukuran papan. 
	
	Selain puzzle yang diambil dari situs daring tersebut, dua papan vaild tambahan berukuran $20 \times 20$ dan $30 \times 30$ telah dibuat untuk pengujian algoritma yang akan diimplementasikan pada tugas akhir ini dan dapat dilihat pada listing {\ref{lst:20x20board}} dan listing {\ref{lst:30x30board}}. Pembuatan papan-papan baru ini dimulai dengan sebuah solusi valid permasalahan N-Queens lalu menambahan sektor-sektor warna sedemikian rupa agar hanya terdapat satu bidak menteri di dalam satu sektor warna.
	
	\begin{lstlisting}[caption={Cuplikan file JSON}, label={lst:jsonSample}]
	[
	{
		"row": 0, // posisi baris
		"col": 0, // posisi kolom
		"color": "rgba(253, 224, 71, 1)" // warna
	},
	]
	\end{lstlisting}
	
	\begin{lstlisting}[caption={Keseluruhan Scraper menggunakan Python}, label={lst:fullscraper}, language=Python]
	from selenium import webdriver
	from selenium.webdriver.common.by import By
	import chromedriver_autoinstaller
	import json
	import time
	import os
	
	# Auto-install ChromeDriver
	chromedriver_autoinstaller.install()
	
	# Base URL
	BASE_URL = "https://www.playqueensgame.com/puzzles/{size}x{size}/{level}"
	
	# Define board sizes and number of levels
	board_levels = {
		7: 50,
		8: 130,
		9: 110,
		10: 60,
		11: 50
	}
	
	# Create output folder
	os.makedirs("boards", exist_ok=True)
	
	# Launch browser
	driver = webdriver.Chrome()
	
	for size, max_level in board_levels.items():
		for level in range(1, max_level + 1):
			url = BASE_URL.format(size=size, level=level)
			driver.get(url)
			time.sleep(2)  # allow page to load
	
			# Extract cells
			cells = driver.find_elements(By.CSS_SELECTOR, "div[data-row][data-col]")
			board = []
			for cell in cells:
				row = int(cell.get_attribute("data-row"))
				col = int(cell.get_attribute("data-col"))
				color = cell.value_of_css_property("background-color")
				board.append({
					"row": row,
					"col": col,
					"color": color
				})
	
			# Sort for consistency
			board.sort(key=lambda c: (c["row"], c["col"]))
	
			# Save JSON
			filename = f"boards/{size}x{size}_level{level}.json"
			with open(filename, "w") as f:
			json.dump(board, f, indent=2)
	
			print(f"Saved {filename}")
	
	driver.quit()
	print("All boards extracted!")
	
	\end{lstlisting}
	
	\begin{lstlisting}[caption={Cuplikan fungsi inti program Python}, label={lst:scraperinti}, language=Python]
		for cell in cells: # untuk setiap cell/kotak dalam papan:
			row = int(cell.get_attribute("data-row")) # ambil posisi baris
			col = int(cell.get_attribute("data-col")) # ambil posisi kolom
			color = cell.value_of_css_property("background-color") # ambil warna kotak tersebut 
			# menambahkan file JSON sesuai format
			board.append({
				"row": row,
				"col": col,
				"color": color
			})
	\end{lstlisting}
	
	\begin{lstlisting} [caption={Papan $20 \times 20$ valid (setiap warna dilambangkan sebagai sebuah karakter yang dimulai dari kode ASCII 'A')}, label={lst:20x20board}] 
	J J J J J J J G G G G G E E E E I I I I
	J J J J J J J G G G G E E E E E I I I I
	J J J J J J J G G G G E E E E E I I I I
	D D D J J J J G G E E E E E R R R I I I
	D D D D D D D D G H E R R R R R R I I I
	D D D D D D U U H H H H P P R R R O I I
	D D D D D U U U H H H H P P P P P O O I
	D D D D U U U U H H H H H P P O O O O O
	D D D D S U U U U H H H H P P O O O O O
	M D S S S U U U U U H H H P K K K O O O
	M M S S S S U U U F H H H K K K K K K K
	M S S S S S S F F F L H K K K K K K K K
	M M M S S S F F F F L L L K K K K K K K
	M M M S S T F F F L L L L L K K K K C C
	M B B B T T L L L L L L L L L K K C C C
	B B B B T T T L L L L L L L A A C C C C
	B B B T T T T T N L L L L A A A C C C C
	B B B T T T T N N N N N A A A A C C C C
	B B B T T T N N N N N N A A A A A C C C
	B B B T T T N N N N N A A A A A A A C C
	\end{lstlisting}
	
	\begin{lstlisting} [caption={Papan $30 \times 30$ valid (setiap warna dilambangkan sebagai sebuah karakter yang dimulai dari kode ASCII 'A')}, label={lst:30x30board}]
	I I I I I I I ^ ^ ^ ^ F F F W W W W W W V V V V V V V V V V
	I I I I I I ^ ^ ^ ^ ^ F F F F W W W W V V V V V V V V V V V
	I I I I _ _ ^ ^ ^ ^ ^ F F F F F W W V V V V V V V V V V V V
	I I I I _ _ _ ^ ^ ^ ^ F F F F F F W V V V V V V V V V V V Z
	I I I _ _ _ _ ^ ^ ^ ^ ^ F F O O O O V V V V V V V V V Z Z Z
	I I _ _ _ _ _ _ ^ ^ ^ O O O O O O O O V V V V V V Z Z Z Z Z
	I _ _ _ _ _ _ _ ^ ^ D [ [ O O C C C C C V V V V Z Z Z Z Z Z
	I _ _ _ _ _ _ _ ^ ^ D [ [ [ C C C C C C C V R R Z Z Z Z Z Z
	_ _ _ _ _ _ _ D D D D [ [ [ C C C C C C C R R R Z Z Z Z Z Z
	\ _ _ G G G G G D D D D [ [ C C C C U U R R R R Z Z Z Z Z Z
	\ \ G G G G G G G D D D [ [ [ C C C U U R R R R Z Z Z Z Z Z
	\ \ G G G G G G G D D D [ [ [ C C U U U R R R R R P Z Z Z Z
	\ \ \ \ G G G G G G D D [ [ [ U U U U U R R R R R P P Z Z Z
	\ \ \ \ \ G G G G G D D [ U U U U U U U U R R R P P P Z Z Z
	\ \ \ \ \ \ G G G G D D [ [ U U U U U U U R R P P P P P P P
	\ \ \ \ \ \ G G G B D D [ [ U U U U U U U R R P P P ] ] ] ]
	\ \ \ \ \ \ \ B B B T T T T U Y Y U Y U S S L L L ] ] ] ] ]
	M M \ \ \ \ \ B B B B T T T Y Y Y Y Y S S S L L L L ] ] ] ]
	M M M M M M B B B B T T T T Y Y Y Y Y S S S S L L L ] ] ] ]
	M M M M M M B B B B T T T T Y Y Y Y Y Y S S S L L L ] ] H H
	M M M M M B B B B B T T T T Y Y Y Y Y Y S S S L L L ] H H H
	M M M X X B B B B B T T T T T Y Y Y Y Y Y Y A A L L H H H H
	M M X X X X B B B B T T T T T T Y Y Y Y Y Y A A A H H H H H
	X X X X X X B B B T T T T T T N N Y Y Y Y A A A A H H H H H
	X X X X X X X B B T T T T T N N N N Y A A A A A A A H H H H
	X X X X X X X J B T T T T T N N N N N A A A A A A A A K K K
	X X X X E E J J J J T T N N N N N N N N A A A A A A K K K K
	E E E E E E E J J J J N N N N N N N N N N A A A A A K K K K
	E E E E E E E J J J J J N N N N N N N N N A A A A A K K K K
	E E E E E J J J J J J J J N N N N N N N N A A A A A K K K K
	\end{lstlisting}
	
	\subsection{Melakukan pemodelan masalah Colored Queens ke dalam bentuk CSP agar dapat diproses oleh algoritma pencarian.}
	{\bf Status :} Ada sejak rencana kerja skripsi.\\
	{\bf Hasil :}\\
	Pemodelan permainan Colored Queens sebagai \textit{Constraint Satisfaction Problem} (CSP) dilakukan untuk memastikan bahwa aturan permainan dapat diproses secara konsisten oleh algoritma Backtracking maupun Particle Swarm Optimization (PSO). Pemodelan ini dilakukan dengan mengidentifikasi tiga komponen utama dalam CSP, yaitu variabel, domain atau ruang solusi, dan kendala sebagai berikut:
	
	\begin{enumerate}
	\item \textbf{Variabel} \\
	Setiap warna pada papan diperlakukan sebagai sebuah variabel. Masing-masing variabel harus ditempatkan tepat satu menteri pada salah satu sel yang termasuk ke dalam sektor warna tersebut.
	
	\item \textbf{Ruang Solusi} \\
	Ruang solusi untuk setiap variabel merupakan himpunan seluruh sel yang memiliki warna yang sesuai dengan variabel tersebut. Dengan demikian, setiap variabel memiliki domain yang berbeda tergantung pada posisi warna di papan.
	
	\item \textbf{Kendala (Constraints)} \\
	Aturan permainan diterjemahkan menjadi sejumlah kendala yang harus dipenuhi secara bersamaan:
	\begin{itemize}
		\item Tidak boleh ada dua menteri yang bersebelahan secara horizontal, vertikal, maupun diagonal.
		\item Setiap warna hanya boleh berisi satu menteri.
		\item Serangan diagonal tidak dihitung, sehingga dua menteri dapat berada pada garis diagonal yang sama selama tidak bersebelahan.
		\item Serangan horizontal dan vertikal tetap berlaku, sehingga dua menteri tidak boleh berada pada baris atau kolom yang sama.
	\end{itemize}
	\end{enumerate}
	
	\textbf{Contoh sederhana:}  
	
	Misalkan papan 4x4 dengan 4 warna berbeda (R, B, G, Y) dan setiap warna membentuk sektor yang tersebar di papan seperti pada \textsuperscript{\ref{lst:4x4example}}
	
	\begin{lstlisting}[caption={papan 4x4 dengan 4 warna berbeda (R, B, G, Y)}, label={lst:4x4example}, basicstyle=\ttfamily, frame=single]
	R B B B
	R R B Y
	G Y Y Y
	G G G Y
	\end{lstlisting}
	
	Papan \textit{Colored Queens} \textsuperscript{\ref{lst:4x4example}} dapat direpresentasikan sebagai CSP dengan ketentuan berikut:
	\begin{itemize}
	\item Variabel: R, B, G, Y
	\item Domain variabel: Semua sel dengan warna yang sesuai
	\begin{itemize}
		\item R: \{(1,1), (2,1), (2,2)\}
		\item B: \{(1,2), (1,3), (1,4), (2,3)\}
		\item G: \{(3,1), (4,1), (4,2), (4,3)\}
		\item Y: \{(2,4), (3,2), (3,3), (3,4), (4,4)\}
	\end{itemize}
	\item Tujuan: Menempatkan satu menteri per warna tanpa melanggar kendala
	\end{itemize}
	
	
	\begin{lstlisting}[caption={Contoh solusi valid dari papan di listing {\ref{lst:4x4example}}}, basicstyle=\ttfamily, frame=single]
	- - Q -
	Q - - -
	- - - Q
	- Q - -
	\end{lstlisting}
	
	Keterangan:
	\begin{itemize}
	\item 'Q' menandakan posisi menteri pada papan.
	\item Setiap menteri berada di sel dengan warna yang berbeda (satu per variabel/warna).
	\item Tidak ada dua menteri yang bersebelahan atau berada pada baris/kolom yang sama.
	\end{itemize}
	
	Dengan pemodelan CSP tersebut, seluruh aturan permainan dapat dinyatakan secara terstruktur sehingga solver dapat melakukan pemeriksaan dan pencarian solusi dengan cara yang konsisten dan sistematis.
	
	\subsection{Melakukan analisis kebutuhan perangkat lunak, baik fungsional maupun non-fungsional, termasuk kebutuhan solver dan antarmuka pengguna.}
	{\bf Status :} Ada sejak rencana kerja skripsi.\\
	{\bf Hasil :}\\
	Berdasarkan hasil analisis dan diskusi mengenai proses bisnis tugas akhir ini, dihasilkan dua \textit{flowchart} yang menggambarkan fungsi-fungsi utama dari sistem yang akan dibangun. Sebuah aplikasi berbasis web akan dikembangkan dengan fungsi utama menyediakan sarana untuk memainkan permainan \textit{Colored Queens} dengan fitur \textit{solver} otomatis yang dapat memberikan solusi valid ketika pemain mengalami kesulitan, seperti yang dipaparkan pada Gambar \ref{fig:flowchart1}. Sistem juga menyediakan fitur perbandingan kinerja antara algoritma Backtracking dan PSO, dengan alur seperti yang ditunjukkan pada Gambar \ref{fig:flowchart2}.
	
	\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\linewidth]{flowchart2.png}
	\caption{\textit{Flowchart} dari proses bisnis pertama, yaitu permainan \textit{Colored Queens} yang berbasis web dan dapat memberikan solusi yang valid kepada pemain dengan memanggil \textit{solver} yang memanfaatkan algoritma backtracking}
	\label{fig:flowchart1}
	\end{figure}
	
	\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{flowchart.png}
	\caption{\textit{Flowchart} dari proses bisnis kedua, yaitu membandingkan performa dua algoritma berbeda, \textit{Backtracking} dan PSO, dalam menyelesaikan masalah \textit{Colored Queens}.}
	\label{fig:flowchart2}
	\end{figure}
	
	\begin{enumerate}
	\item \textbf{Kebutuhan Fungsional Sistem} \\
	Untuk membangun permainan \textit{Colored Queens}, sistem akan dibangun dengan arsitektur berbasis web, menggunakan \textit{frontend} React dan \textit{backend} Spring Boot. \textit{Frontend} bertugas menampilkan papan permainan, menerima input pengguna, memberikan umpan balik visual secara real-time, dan menyediakan antarmuka interaktif untuk bermain atau menguji solusi. \textit{Backend} menjalankan \textit{solver} Java yang mengimplementasikan algoritma Backtracking degan AC-3 dan Particle Swarm Optimization (PSO), serta menangani logika validasi.
	
	\item \textbf{Situs Web dan Pemilihan Papan} \\
	Aplikasi akan mengelompokkan papan-papan yang dapat dimainkan berdasarkan ukuran agar mudah dinavigasikan. Pemain juga dapat memilih papan secara acak dari daftar tersebut dan halaman web akan menampilkan papan yang sesuai dengan pilihan pemain.
	
	\item \textbf{Mengambil data papan dari JSON} \\
	Ketika pemain memilih salah satu papan untuk dimainkan, \textit{Frontend} aplikasi web akan mengambil keseluruhan data papan dari file JSON yang tersedia setelah menjalankan \textit{web scraper}, seperti yang dijelaskan di bagian \ref{lst:fullscraper}, lalu memprosesnya menjadi papan berwarna yang dapat ditampilkan dan dimainkan.
	
	\item \textbf{Adaptasi Algoritma Backtracking dengan AC-3} \\
	Algoritma Backtracking standar untuk Colored Queens menggunakan pendekatan rekursif untuk menempatkan setiap menteri berdasarkan warna pada papan. Agar lebih efisien, algoritma ini akan digabungkan dengan \textit{Arc Consistency Algorithm 3} (AC-3) untuk menyempitkan ruang solusi sebelum dan selama pencarian.
	
	\textbf{Proses Backtracking dengan AC-3:}
	\begin{enumerate}
		\item \textbf{Inisialisasi:} Setiap warna direpresentasikan sebagai variabel, dan domainnya adalah semua posisi yang valid dalam warna tersebut.
		\item \textbf{Preprocessing AC-3:} Jalankan AC-3 untuk mengeliminasi posisi yang jelas tidak mungkin, misalnya karena konflik adjacency atau serangan langsung.
		\item \textbf{Rekursi Backtracking:} 
		\begin{itemize}
			\item Pilih variabel warna berikutnya.
			\item Coba setiap posisi dalam domain yang tersisa.
			\item Jika posisi valid (tidak melanggar adjacency atau aturan serangan):
			\begin{itemize}
				\item Tempatkan menteri pada posisi tersebut.
				\item Jalankan AC-3 lagi untuk memperbarui domain variabel lain.
				\item Lanjutkan ke variabel warna berikutnya secara rekursif.
			\end{itemize}
			\item Jika tidak ada posisi valid, mundur (\textit{backtrack}) ke variabel sebelumnya dan coba posisi lain.
		\end{itemize}
		\item \textbf{Kondisi berhenti:} Semua warna telah ditempatkan tanpa konflik → solusi valid ditemukan.
	\end{enumerate}
	
	\item \textbf{Adaptasi Algoritma PSO} \\
	PSO biasanya digunakan untuk optimasi kontinu. Agar dapat diterapkan pada masalah diskret seperti Colored Queens, beberapa modifikasi dilakukan:
	\begin{enumerate}
		\item \textbf{Representasi Partikel:} Setiap partikel adalah solusi kandidat, direpresentasikan sebagai array integer di mana elemen ke-$i$ menunjukkan posisi ke-$n$ dari warna $i$.
		\item \textbf{Velocity Diskret:} Velocity yang semula berupa jarak perpindahan kontinu diubah menjadi probabilitas pertukaran posisi dengan \textit{neighborhood best} (nBest). Misalnya, partikel $[2,2,4,1]$ dengan velocity $[0.3,0.5,0.4,0.6]$ berarti elemen ke-1 yang bernilai 2 memiliki kemungkinan 0.3 untuk diubah menjadi nilai yang sesuai di nBest.
		\item \textbf{Update Velocity:} Velocity diperbarui menggunakan rumus standar PSO:
		\[
		v[i] = \omega \cdot v[i] + c_1 \cdot r_1 \cdot \Delta_p[i] + c_2 \cdot r_2 \cdot \Delta_n[i]
		\]
		di mana $\Delta_p[i]$ dan $\Delta_n[i]$ adalah nilai boolean yang menunjukkan apakah posisi saat ini berbeda dari pBest/nBest, dan $c_1,c_2,r_1,r_2$ mengikuti nilai konvensional PSO.
		\item \textbf{Update Partikel:} Setiap partikel akan diperbarui berdasarkan \textit{velocity} barunya yang sudah dihitung dengan cara mengambil nilai acak untuk setiap elemen $i$. Apabila nilai acak $<$ \textit{velocity}, elemen tersebut akan mengubah nilainya sesuai dengan elemen pada posisi yang sama di nBest. Apabila nilai acak $>$ \textit{velocity}, elemen tidak akan mengalami perubahan.
		\item \textbf{Fungsi Fitness:} \textit{Fitness} dihitung untuk meminimalkan pelanggaran adjacency dan serangan dengan:
		\[
		\text{fitness} = w_1 \cdot \text{adjacencyViolation} + w_2 \cdot \text{attackingViolation}
		\]
		
		dimana nilai \textit{Fitness} yang optimal adalah 0.
	\end{enumerate}
	\textbf{Contoh iterasi PSO} \\
	Contoh iterasi ini menggunakan papan pada listing {\ref{lst:4x4example}} dengan parameter $\omega = 0.7$, $c_1 = 2$, $c_2 = 2$, $r_1 = 0.2$, dan $r_2 = 0.2$. nBest juga ditetapkan sebagai $[2,1,3,4]$ dan pBest sebagai $[2,3,3,2]$. Bobot dari pelanggaran ditetapkan sebagai $w_1 (adjacency) = 2$ dan $w_2 (attacking) = 1$
	\begin{enumerate}[label=\arabic*.]
		\item Inisialisasi partikel secara acak, sebagai contoh $[2,4,3,3]$ yang dapat dibaca sebagai:
		\begin{itemize}
			\item R → posisi ke-2 = $(2,1)$
			\item B → posisi ke-1 = $(2,3)$
			\item G → posisi ke-3 = $(4,2)$
			\item Y → posisi ke-3 = $(3,3)$
		\end{itemize}
		dengan \textit{velocity} awal sebagai $[0.3,0.5,0.4,0.6]$
		\item Hitung \textit{velocity} baru dengan menghitung: 
		\begin{itemize}
			\item $0.7 \cdot 0.3 + 2.0 \cdot 0.2 \cdot 0 + 2.0 \cdot 0.2 \cdot 0 = 0.21$
			\item $0.7 \cdot 0.5 + 2.0 \cdot 0.2 \cdot 0 + 2.0 \cdot 0.2 \cdot 1 = 0.75$
			\item $0.7 \cdot 0.4 + 2.0 \cdot 0.2 \cdot 0 + 2.0 \cdot 0.2 \cdot 0 = 0.28$
			\item $0.7 \cdot 0.6 + 2.0 \cdot 0.2 \cdot 1 + 2.0 \cdot 0.2 \cdot 0 = 0.82$
		\end{itemize}
		Maka $(v + 1) = [0.21,0.75,0.28,0.82]$
		\item Hitung posisi baru partikel tersebut dengan cara mengambil nilai acak untuk setiap elemen:
		\begin{itemize}
			\item Elemen 1 → $0.3 > 0.21 \therefore$ tidak terjadi perubahan.
			\item Elemen 2 → $0.78 > 0.75 \therefore$ tidak terjadi perubahan
			\item Elemen 3 → $0.4 > 0.28 \therefore$ tidak terjadi perubahan.
			\item Elemen 4 → $0.45 < 0.82 \therefore$ nilai berubah sesuai dengan nBest (4).
		\end{itemize}
		Maka $x + (v + 1) = [2,4,3,4]$
		\item Hitung fitness untuk kondisi partikel sekarang berdasarkan posisi bidak menteri:
		\begin{itemize}
			\item Bidak 1 → $(2,1)$\\
			Adjacency Violation dengan Bidak 2
			\item Bidak 2 → $(1,2)$\\
			Adjacency Violation dengan Bidak 1 \\
			Attacking Violation dengan bidak 3
			\item Bidak 3 → $(4,2)$\\
			Attacking Violation dengan bidak 2
			\item Bidak 4 → $(3,4)$\\
			Maka fitness partikel ini adalah:
			\[
			\text{fitness} = 2 \cdot 2 + 1 \cdot 2 = 6
			\]
		\end{itemize}
		\item Evaluasi pBest dan nBest
		\begin{itemize}
			\item Fitness pBest = 10 
			\item Fitness nBest = 8
			\item Current Fitness = 6
			
			Karena current fitness < nbest, kedua pBest dan nBest ditukar dengan partikel sekarang. Sehingga nBest = pBest = $[0.21,0.75,0.28,0.82]$ dan Fitness nBest = Fitness pBest = 6
		\end{itemize}
		
	\end{enumerate}
	
	\item \textbf{Optimasi menggunakan \textit{BitSet}}
	\begin{itemize}
		\item Untuk meningkatkan efisiensi, baik Backtracking maupun PSO memanfaatkan \textit{bitset} untuk memantau baris, kolom, dan warna yang sudah ditempati.
		\item Pengecekan konflik dapat dilakukan dalam waktu konstan $O(1)$ menggunakan operasi logika bitwise.
		\item \textit{Bitset} juga memungkinkan perhitungan adjacency violation secara cepat dengan operasi AND/OR pada \textit{mask} bit.
	\end{itemize}
	
	\item \textbf{Integrasi Web dan Solver} \\
	Pada sistem ini, papan permainan Colored Queens sepenuhnya di-render oleh React di sisi klien. Pengguna dapat menempatkan menteri, memindahkan bidak, dan menerima umpan balik secara real-time mengenai pelanggaran aturan atau saran langkah, tanpa memerlukan komunikasi dengan \textit{backend}. Hal ini memastikan pengalaman bermain yang interaktif dan responsif.
	
	Fitur \textit{solver} (menggunakan Backtracking atau PSO) hanya akan dipanggil melalui \textit{backend} Spring Boot ketika pengguna menekan tombol \textit{Solve} untuk papan berukuran hingga 11×11. Backend akan memproses perhitungan, mengembalikan solusi beserta informasi tambahan seperti langkah-langkah penempatan menteri dan status validasi. React kemudian akan menampilkan solusi ini pada papan secara visual.
	
	Untuk papan yang lebih besar (20×20 dan 30×30), \textit{solver} tidak dijalankan secara real-time. Sebagai gantinya, solusi telah disiapkan sebelumnya dan hanya ditampilkan oleh frontend, sehingga pengguna tetap dapat melihat hasil tanpa menunggu proses komputasi yang berat.
	
	Dengan arsitektur ini, interaksi normal pengguna tetap cepat dan sepenuhnya client-side, sedangkan operasi komputasi berat dialihkan ke server hanya ketika diperlukan.
	
	\item \textbf{Perbandingan Kinerja Algoritma} \\
	Agar proses penelitian lebih cepat dan efisien, perbandingan kinerja algoritma tidak dilakukan melalui antarmuka web, melainkan menggunakan \textit{Command Line Interface} (CLI). Pendekatan ini memungkinkan perubahan \textit{hyperparameter} dengan mudah dan eksekusi pengujian secara otomatis tanpa \textit{overhead rendering} antarmuka grafis, sehingga waktu eksekusi murni dari algoritma dapat diukur dengan lebih akurat.
	\end{enumerate}
	
	\subsection{Merancang arsitektur sistem serta antarmuka pengguna untuk aplikasi Colored Queens Solver.}
	{\bf Status :} Ada sejak rencana kerja skripsi.\\
	{\bf Hasil :}\\
	\subsubsection{Arsitektur sistem dalam bentuk \textit{Class Diagram}}
	\begin{figure}
		\centering
		\includegraphics[width=0.9\linewidth]{cDiagram.png}
		\caption{\textit{Class Diagram} dari \textit{solver} \textit{Colored Queens} yang akan dibangun pada tugas akhir ini}
		\label{fig:cDiagram}
	\end{figure}

	Gambar \ref{fig:cDiagram} menunjukkan diagram kelas utama yang digunakan dalam implementasi sistem \textit{Colored Queens} beserta kedua \textit{solver} yang dikembangkan. Diagram ini memberikan gambaran umum mengenai struktur kelas, atribut penting, metode inti, serta relasi antarkomponen yang menyusun arsitektur sistem.
	
	Secara keseluruhan, terdapat empat kelas utama, yaitu \texttt{Cell}, \texttt{Board}, \texttt{BacktrackingSolverAC3}, dan \texttt{PSOSolver}, dengan satu kelas internal tambahan yaitu \texttt{Particle} yang merupakan bagian dari \texttt{PSOSolver}. Berikut adalah penjelasan tiap elemen dan hubungan antarkelas dalam diagram.
	
	\begin{itemize}
		\item \textbf{Cell}  
		Kelas ini merepresentasikan sebuah sel pada papan. Setiap sel memiliki koordinat baris dan kolom, serta nilai warna dalam format RGB. Kelas ini berfungsi sebagai unit data dasar yang kemudian dikelompokkan oleh kelas \texttt{Board}.
		
		\textit{Metode utama:}
		\begin{itemize}
			\item \texttt{Cell(row, col, r, g, b)}: Konstruktor untuk inisialisasi sel dengan koordinat dan nilai warna RGB
			\item \texttt{getter()} dan \texttt{setter()}: Metode akses untuk membaca dan mengubah atribut sel
			\item \texttt{toString()}: Menghasilkan representasi string dari sel dalam format \texttt{Cell[row=x, col=y, rgb=(r,g,b)]}
		\end{itemize}
		
		\item \textbf{Board}  
		Kelas ini mengelola struktur papan dan memetakan setiap warna ke daftar sel yang ditempati. \texttt{Board} membangun \textit{colorMap} dan \textit{colorSymbolMap}, serta menyediakan metode untuk memperoleh sel berdasarkan warna dan menampilkan papan. Kelas ini menjadi dependensi utama bagi kedua algoritma \textit{solver}.
		
		\textit{Metode utama:}
		\begin{itemize}
			\item \texttt{Board(size, cells)}: Konstruktor yang membangun papan dengan ukuran tertentu dan daftar sel, kemudian memanggil \texttt{buildColorMap()} dan \texttt{buildColorSymbols()}
			\item \texttt{buildColorMap(cells)}: Memetakan setiap warna RGB unik ke daftar posisi sel yang memiliki warna tersebut
			\item \texttt{buildColorSymbols(cells)}: Memberikan simbol huruf (A, B, C, ...) untuk setiap warna unik, melewati 'Q' yang digunakan untuk menteri
			\item \texttt{getCellsByColor(colorKey)}: Mengembalikan daftar posisi sel untuk warna tertentu
			\item \texttt{getSymbolForColor(colorKey)}: Mengembalikan simbol huruf yang merepresentasikan warna tertentu
			\item \texttt{printBoard()}: Mencetak papan dalam format grid dengan simbol warna
		\end{itemize}
		
		\item \textbf{BacktrackingSolverAC3}  
		Kelas ini mengimplementasikan algoritma \textit{Backtracking} yang diperkaya dengan propagasi kendala AC-3. Di dalamnya terdapat struktur optimisasi seperti \textit{bitset}, \textit{prune stack}, dan matriks okupansi. Kelas ini bergantung pada \texttt{Board} untuk memperoleh domain warna dan posisi sel, lalu melakukan pencarian solusi secara deterministik.
		
		\textit{Metode utama:}
		\begin{itemize}
			\item \texttt{BacktrackingSolverAC3(board)}: Konstruktor yang menginisialisasi solver, memetakan sel ke dalam \textit{BitSet} untuk pelacakan domain valid, dan menyiapkan stack untuk merekam aksi pemangkasan (\textit{pruning})
			\item \texttt{solve()}: \textit{Entry point} utama yang memulai pencarian solusi dan menghitung statistik waktu eksekusi
			\item \texttt{placeQueens(colorIndex)}: Metode rekursif utama yang mencoba menempatkan menteri pada posisi valid, lalu memicu \textit{forward checking} dan propagasi AC-3 sebelum lanjut ke warna berikutnya
			\item \texttt{forwardCheck(row, col, placedColorIndex)}: Melakukan penyaringan awal (\textit{filtering}) dengan menghapus nilai-nilai pada domain warna masa depan yang berkonflik langsung dengan menteri yang baru ditempatkan menggunakan perhitungan konflik \textit{inline}
			\item \texttt{propagateArcs(queue)}: Mengelola antrean (\textit{queue}) pasangan variabel untuk algoritma AC-3, memastikan bahwa setiap pengurangan domain dipropagasikan ke variabel tetangga yang relevan
			\item \texttt{revise(fromColorIdx, toColorIdx)}: Inti dari logika AC-3; memeriksa apakah setiap nilai dalam domain tujuan (\textit{toColor}) memiliki dukungan (\textit{support}) yang valid di domain asal (\textit{fromColor}), dan memangkas nilai yang tidak memiliki dukungan
			\item \texttt{conflicts(cell1, cell2)}: Metode utilitas untuk memeriksa apakah dua sel saling menyerang (baris sama, kolom sama, atau bersebelahan/tetangga 8 arah)
			\item \texttt{undoPrunes(pruneStartPos)}: Mengembalikan nilai-nilai ke dalam domain (\textit{BitSet}) yang sebelumnya dipangkas, dipanggil saat algoritma melakukan \textit{backtrack}
			\item \texttt{anyColorExhausted(currentColorIndex)}: Memeriksa apakah terjadi \textit{domain wipeout} (domain kosong) pada warna apa pun di masa depan, yang menandakan jalur solusi saat ini gagal
			\item \texttt{getSolution()}, \texttt{getSteps()}, \texttt{getExecutionTime()}: Mengembalikan hasil solusi akhir dan statistik kinerja algoritma
		\end{itemize}
		
		\item \textbf{PSOSolver}  
		Kelas ini mengimplementasikan algoritma \textit{Particle Swarm Optimization} (PSO) yang telah dimodifikasi untuk permasalahan diskret Colored Queens. PSO bekerja dengan membangkitkan populasi partikel, memperbarui \textit{velocity}, memindahkan posisi partikel, menghitung \textit{fitness}, serta menentukan \textit{global best}. Kelas ini juga bergantung pada \texttt{Board} untuk mendapatkan domain posisi tiap warna.
		
		\textit{Metode utama:}
		\begin{itemize}
			\item \texttt{PSOSolver(board, swarmSize, maxIterations)}: Konstruktor yang menginisialisasi solver PSO dengan board, ukuran \textit{swarm}, dan jumlah iterasi maksimum
			\item \texttt{setParameters(w, c1, c2, r1, r2, w1, w2)}: Mengatur parameter PSO (\textit{inertia weight}, \textit{cognitive/social coefficients}, faktor random, bobot fitness)
			\item \texttt{solve()}: \textit{Entry point} utama PSO yang menginisialisasi \textit{swarm}, melakukan iterasi update, dan mengembalikan solusi \textit{global best}
			\item \texttt{initializeSwarm()}: Membangkitkan populasi awal partikel dengan posisi dan \textit{velocity} acak dalam domain yang valid
			\item \texttt{evaluateFitness(particle)}: Menghitung fitness satu partikel menggunakan formula: \texttt{w1 × adjacencyViolations + w2 × attackingViolations}
			\item \texttt{updateVelocity(particle, pBest, nBest)}: Memperbarui \textit{velocity} partikel menggunakan formula PSO yang diadaptasi untuk ruang diskret: $v = \omega \cdot v + c_1 \cdot r_1 \cdot (pBest - x) + c_2 \cdot r_2 \cdot (nBest - x)$
			\item \texttt{updatePosition(particle)}: Memperbarui posisi partikel berdasarkan \textit{velocity} dengan mekanisme \textit{swap} probabilistik
			\item \texttt{computeXplusOne(x, vPlusOne, boolean[], nBest)}: Menghitung posisi baru partikel berdasarkan \textit{velocity} dan \textit{neighborhood best}
			\item \texttt{findNeighborhoodBest(index)}: Mencari partikel dengan fitness terbaik dalam \textit{neighborhood} (topologi ring atau global)
			\item \texttt{getSteps()}: Mengembalikan jumlah iterasi yang dilakukan
		\end{itemize}
		
		\item \textbf{Particle} (kelas internal dari \texttt{PSOSolver})  
		Kelas ini mewakili satu kandidat solusi dalam PSO. Setiap partikel memiliki posisi, \textit{velocity}, nilai fitness, dan \textit{personal best}. Karena partikel sepenuhnya dikelola oleh \texttt{PSOSolver}, relasinya ditunjukkan dengan komposisi (\textit{black diamond}).
		
		\textit{Metode utama:}
		\begin{itemize}
			\item \texttt{Particle(size)}: Konstruktor yang menginisialisasi partikel dengan array \texttt{position} dan \texttt{velocity} sesuai jumlah warna
			\item \texttt{getPosition()}, \texttt{setPosition()}: Mengakses dan mengubah posisi partikel (array indeks posisi untuk setiap warna)
			\item \texttt{getVelocity()}, \texttt{setVelocity()}: Mengakses dan mengubah \textit{velocity} partikel (array probabilitas pertukaran)
			\item \texttt{getPBest()}, \texttt{setPBest()}: Mengakses dan mengubah posisi \textit{personal best}
			\item \texttt{updateFitness(value)}: Memperbarui nilai fitness saat ini
			\item \texttt{updatePBest()}: Memperbarui \textit{personal best} jika fitness saat ini lebih baik
			\item \texttt{clone()}: Membuat salinan independen dari partikel untuk keperluan komparasi atau backup
		\end{itemize}
		
	\end{itemize}
	
	Relasi antarkelas dalam diagram dapat diringkas sebagai berikut:
	\begin{itemize}
		\item \texttt{Board} \textbf{mengandung} banyak \texttt{Cell}.
		\item \texttt{BacktrackingSolverAC3} \textbf{bergantung pada} \texttt{Board} untuk membaca struktur domain.
		\item \texttt{PSOSolver} juga \textbf{bergantung pada} \texttt{Board} karena menggunakan informasi warna dan posisi sel.
		\item \texttt{PSOSolver} \textbf{memiliki komposisi} terhadap kelas \texttt{Particle}, yang menunjukkan bahwa \texttt{Particle} tidak berdiri sendiri dan hanya ada sebagai bagian internal dari proses PSO.
	\end{itemize}
	
	Dengan demikian, Gambar~\ref{fig:cDiagram} menggambarkan arsitektur lengkap sistem Colored Queens beserta algoritma pencarian yang digunakan, serta menunjukkan pembagian tanggung jawab masing-masing kelas dalam proses penyelesaian masalah.
	\subsubsection{\textit{Low-fidelity mockup} dari antarmuka aplikasi web}
	Bagian ini menyajikan rancangan antarmuka awal dari sistem \textit{Colored Queens}. \textit{Mockup} ini bertujuan untuk menggambarkan struktur halaman, letak komponen utama, serta alur interaksi pengguna secara sederhana tanpa mempertimbangkan aspek visual akhir. Desain dapat berubah pada implementasi \textit{high-fidelity} atau tahap pengembangan berikutnya.
	
	\begin{enumerate}
		\item \textbf{Halaman Utama}
		
		Gambar \ref{fig:mockup_homepage} menunjukan halaman utama yang merupakan titik masuk pertama ketika pengguna mengunjungi situs \textit{Colored Queens}. Pengguna diperkenalkan dengan tampilan sederhana yang berfokus pada tombol utama untuk memulai permainan.
		
		\begin{figure}
			\centering
			\includegraphics[width=1\linewidth]{/mockup/homepage.png}
			\caption{Tampilan halaman utama ketika pengguna pertama kali mengunjungi situs \textit{Colored Queens}. Pengguna dapat mengklik tombol "Play!" untuk memulai permainan.}
			\label{fig:mockup_homepage}
		\end{figure}
		
		\noindent \textbf{Komponen-komponen:}
		\begin{enumerate}
			\item[1.] \textbf{Kata Sambutan:} Teks sapaan atau judul permainan yang berfungsi menyambut pengguna serta menampilkan identitas aplikasi \textit{Colored Queens}.
			\item[2.] \textbf{Tombol mulai permainan/\textit{Play!}:} Tombol interaksi utama yang mengarahkan pengguna menuju halaman pemilihan tingkat kesulitan (\textit{Level Selector}) untuk memulai sesi permainan.
		\end{enumerate}
		
		\item \textbf{Pemilihan Tingkat Kesulitan}
		
		Setelah menekan tombol \textit{Play}, pengguna diarahkan menuju halaman pemilihan tingkat kesulitan seperti terlihat pada Gambar \ref{fig:mockup_levelSelector}.
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=1\linewidth]{/mockup/levelSelector.png} % Pastikan nama file sesuai
			\caption{Halaman pemilihan tingkat kesulitan yang membagi level berdasarkan ukuran grid.}
			\label{fig:mockup_levelSelector}
		\end{figure}
		
		\noindent \textbf{Komponen-komponen:}
		\begin{enumerate}
			\item[1.] \textbf{Judul Utama:} Instruksi untuk memilih tingkat kesulitan.
			\item[2.] \textbf{Judul Kategori Tantangan:} Bagian khusus untuk level dengan ukuran papan ekstrem.
			\item[3.] \textbf{Label Kategori:} Penanda tingkat kesulitan (\textit{Easy}, \textit{Medium}, \textit{Hard}).
			\item[4.] \textbf{Tombol Level Standar:} Tombol untuk memilih ukuran papan umum ($7\times7$ hingga $11\times11$).
			\item[5.] \textbf{Tombol Level Tantangan:} Tombol untuk memilih ukuran papan besar ($20\times20$ dan $30\times30$).
		\end{enumerate}
		
		\item \textbf{Halaman Level / Papan Permainan}
		
		Pada halaman \ref{fig:mockup_game}, pengguna berinteraksi langsung dengan papan permainan. Detail antarmuka dapat dilihat pada gambar berikut:
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=1\linewidth]{/mockup/level.png} % Menggunakan gambar yang ada label 1-9
			\caption{Tampilan antarmuka permainan utama beserta instrumen pendukungnya.}
			\label{fig:mockup_game}
		\end{figure}
		
		\noindent \textbf{Komponen-komponen:}
		\begin{enumerate}
			\item[1.] \textbf{Indikator Ukuran:} Menampilkan dimensi papan yang sedang dimainkan.
			\item[2.] \textbf{Indikator Level:} Menampilkan nomor level saat ini.
			\item[3.] \textbf{Area Papan Permainan:} \textit{Grid} tempat permainan berlangsung.
			\item[4.] \textbf{Bidak Menteri (\textit{Queen}):} Objek permainan yang dapat ditempatkan oleh pemain.
			\item[5.] \textbf{Dropdown Ukuran:} Navigasi cepat untuk mengganti ukuran papan.
			\item[6.] \textbf{Dropdown Level:} Navigasi cepat untuk berpindah level dalam ukuran yang sama.
			\item[7.] \textbf{Timer:} Penghitung durasi permainan yang dimulai saat pemain menempatkan bidak menteri pertamanya.
			\item[8.] \textbf{Tombol Hint:} Tombol untuk meminta bantuan sistem.
			\item[9.] \textbf{Tombol Solve:} Tombol untuk menyerah dan melihat solusi otomatis. Tombol ini akan memanggil fungsi/algoritma pencarian untuk menemukan solusi valid untuk papan yang sedang ditampilkan.
		\end{enumerate}
		
		\item \textbf{\textit{Hint} / Petunjuk}
		
		Fitur \textit{hint} memberikan bantuan visual dalam tiga bentuk. Pertama, rekomendasi langkah valid (Gambar \ref{fig:mockup_hint1}).
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=1\linewidth]{/mockup/hint1.png}
			\caption{Visualisasi \textit{hint} rekomendasi langkah.}
			\label{fig:mockup_hint1}
		\end{figure}
		
		\noindent \textbf{Komponen-komponen:}
		\begin{enumerate}
			\item[1.] \textbf{Highlight Hijau:} Menandakan sel kosong yang aman dan disarankan untuk ditempati menteri.
		\end{enumerate}
		
		Kedua, koreksi kesalahan (Gambar \ref{fig:mockup_hint2}) jika pemain menempatkan bidak di posisi yang salah di suatu sektor warna.
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=1\linewidth]{/mockup/hint2.png}
			\caption{Visualisasi \textit{hint} korektif.}
			\label{fig:mockup_hint2}
		\end{figure}
		
		\noindent \textbf{Komponen-komponen:}
		\begin{enumerate}
			\item[1.] \textbf{Highlight Merah:} Menandakan bidak menteri yang posisinya salah pada suatu warna dan harus dipindahkan ke posisi lain pada sektor warna yang sama.
			\item[2.] \textbf{Highlight Oranye:} Menandakan sel tujuan yang benar untuk memindahkan bidak yang salah tersebut.
		\end{enumerate}
		
		Ketiga, fitur \textit{Auto-solve} (Gambar \ref{fig:mockup_solved_by_solver}) yang akan memanggil algoritma pencarian untuk menyelesaikan masalah (kecuali untuk papan ukuran besar).
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=1\linewidth]{/mockup/solved_by_solver.png}
			\caption{Kondisi papan setelah fitur \textit{Solve} diaktifkan.}
			\label{fig:mockup_solved_by_solver}
		\end{figure}
		
		\noindent \textbf{Komponen-komponen:}
		\begin{enumerate}
			\item[1.] \textbf{Bidak Hijau:} Menandakan seluruh menteri telah ditempatkan di posisi solusi yang benar oleh sistem.
		\end{enumerate}
		
		\item \textbf{\textit{Warning} / Peringatan}
		
		Sistem memberikan peringatan visual merah jika terjadi pelanggaran aturan. Contoh pelanggaran \textit{adjacency} (bersebelahan) terlihat pada Gambar \ref{fig:mockup_warning_adjacent}.
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=1\linewidth]{/mockup/warning_adjacent.png}
			\caption{Indikator kesalahan aturan \textit{adjacency}.}
			\label{fig:mockup_warning_adjacent}
		\end{figure}
		
		\noindent \textbf{Komponen-komponen:}
		\begin{enumerate}
			\item[1.] \textbf{Area Merah (Kotak 3x3):} Menandakan konflik karena dua menteri berada terlalu dekat (radius 1 petak).
		\end{enumerate}
		
		Pelanggaran pada baris atau kolom ditunjukkan pada Gambar \ref{fig:mockup_warning_horizontal} dan \ref{fig:mockup_warning_vertical}.
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=1\linewidth]{/mockup/warning_horizontal.png}
			\caption{Visualisasi konflik horizontal.}
			\label{fig:mockup_warning_horizontal}
		\end{figure}
		
		\noindent \textbf{Komponen-komponen:}
		\begin{enumerate}
			\item[1.] \textbf{Highlight Baris Merah:} Menandakan terdapat lebih dari satu menteri pada baris yang sama.
		\end{enumerate}
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=1\linewidth]{/mockup/warning_vertical.png}
			\caption{Visualisasi konflik vertikal.}
			\label{fig:mockup_warning_vertical}
		\end{figure}
		
		\noindent \textbf{Komponen-komponen:}
		\begin{enumerate}
			\item[1.] \textbf{Highlight Kolom Merah:} Menandakan terdapat lebih dari satu menteri pada kolom yang sama.
		\end{enumerate}
		
		Pelanggaran aturan warna (Gambar \ref{fig:mockup_warning_color}).
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=1\linewidth]{/mockup/warning_color.png}
			\caption{Peringatan spesifik wilayah warna.}
			\label{fig:mockup_warning_color}
		\end{figure}
		
		\noindent \textbf{Komponen-komponen:}
		\begin{enumerate}
			\item[1.] \textbf{Highlight Area Warna Merah:} Menandakan satu wilayah warna telah diisi oleh lebih dari satu menteri.
		\end{enumerate}
		
		\item \textbf{Halaman Menang}
		
		Setelah pemain menyelesaikan puzzle, halaman kemenangan ditampilkan (Gambar \ref{fig:mockup_win}).
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=1\linewidth]{/mockup/win.png}
			\caption{Tampilan layar kemenangan.}
			\label{fig:mockup_win}
		\end{figure}
		
		\noindent \textbf{Komponen-komponen:}
		\begin{enumerate}
			\item[1.] \textbf{Ikon Trofi:} Ilustrasi visual keberhasilan.
			\item[2.] \textbf{Modal Box:} Jendela \textit{pop-up} yang memuat informasi kemenangan.
			\item[3.] \textbf{Informasi Waktu:} Menampilkan durasi penyelesaian level.
			\item[4.] \textbf{Tombol Next:} Tombol untuk langsung melanjutkan ke level berikutnya.
			\item[5.] \textbf{Tombol Level Picker:} Tombol untuk kembali ke menu pemilihan level.
			\item[6.] \textbf{Overlay Latar Belakang:} Lapisan semi-transparan yang menutupi papan permainan untuk memfokuskan perhatian pemain pada pesan kemenangan.
		\end{enumerate}
		
	\end{enumerate}
	
	\subsection{Menyusun dokumentasi tugas akhir untuk tahap TA 1.}
	{\bf Status :} Ada sejak rencana kerja skripsi.\\
	{\bf Hasil :}\\
	Bagian latar belakang, dasar teori dan analisis dapat diambil dari dokumen ini. Dasar teoru dapat diambil dari bagian \ref{dasarteori} sedangkan bagian analisis dapat diambil dari bagian \ref{analisis1} dan \ref{analisis2}.
	
	\subsection{Mengimplementasikan Solver menggunakan algoritma Backtracking murni yang tidak terintegrasi dengan algoritma AC-3 sebagai tolok ukur}
	{\bf Status :} Ditambah di semester ini.\\
	{\bf Hasil :}\\
	Untuk merepresentasikan \textit{puzzle} \textit{Colored Queens} secara terstruktur, sistem dilengkapi dengan kelas Board dan Cell yang digunakan untuk menyimpan konfigurasi papan dan properti setiap sel. Pemisahan model ini mempermudah proses validasi kendala, pembacaan pola warna, serta integrasi \textit{solver} dengan antarmuka pengguna. Keduanya berperan dalam jalannya algoritma pencarian, serta membangun dan mengevaluasi solusi.
	\begin{lstlisting}[language=Java, caption={Kelas \texttt{Board} untuk merepresentasikan papan \textit{Colored Queens}}, label={lst:boardCode}]
		public class Board {
			private int size;
			private Map<String, List<int[]>> colorMap = new HashMap<>();
			private Map<String, String> colorSymbolMap = new HashMap<>();
			
			public Board(int size, List<Cell> cells) {
				this.size = size;
				buildColorMap(cells);
				buildColorSymbols();
			}
			
			//memetakan setiap posisi warna ke dalam map
			private void buildColorMap(List<Cell> cells) {
				for (Cell cell : cells) {
					String colorKey = String.format("%d,%d,%d", cell.getR(), cell.getG(), cell.getB());
					colorMap.computeIfAbsent(colorKey, k -> new ArrayList<>())
					.add(new int[]{cell.getRow(), cell.getCol()});
				}
			}
			
			//menggunakan huruf (A,B,C,D, dst.) untuk memodelkan warna RGB yang unik
			private void buildColorSymbols() {
				char symbol = 'A';
				for (String color : colorMap.keySet()) {
					if (symbol == 'Q') {
						symbol++;
					}
					colorSymbolMap.put(color, String.valueOf(symbol));
					symbol++;
				}
			}
			
			public int getSize() {
				return size;
			}
			
			public Map<String, List<int[]>> getColorMap() {
				return colorMap;
			}
			
			public Map<String, String> getColorSymbolMap() {
				return colorSymbolMap;
			}
			
			//mengembalikan semua cell yang merupakan suatu warna
			public List<int[]> getCellsByColor(String colorKey) {
				return colorMap.getOrDefault(colorKey, Collections.emptyList());
			}
			
			//mengembalikan huruf yang merepresentasikan suatu key RGB
			public String getSymbolForColor(String colorKey) {
				return colorSymbolMap.getOrDefault(colorKey, "?");
			}
			
			//print dalam format huruf
			public void printSymbolBoard() {
				String[][] grid = new String[size][size];
				for (Map.Entry<String, List<int[]>> entry : colorMap.entrySet()) {
					String symbol = getSymbolForColor(entry.getKey());
					for (int[] cell : entry.getValue()) {
						grid[cell[0]][cell[1]] = symbol;
					}
				}
				
				for (int r = 0; r < size; r++) {
					for (int c = 0; c < size; c++) {
						System.out.print((grid[r][c] != null ? grid[r][c] : ".") + " ");
					}
					System.out.println();
				}
			}
			
			//logging
			public void printColorSummary() {
				System.out.println("Board color distribution:");
				for (String color : colorMap.keySet()) {
					String symbol = getSymbolForColor(color);
					System.out.printf("Color %s (%s) -> %d cells%n",
					color, symbol, colorMap.get(color).size());
				}
				System.out.println("Board size: " + size);
				System.out.println("Unique colors: " + colorMap.size());
			}
		}
	\end{lstlisting}
	
	\begin{lstlisting}[language=Java, caption={Kelas \texttt{Cell} untuk merepresentasikan satu kotak di dalam papan \textit{Colored Queens} yang menyimpan posisi dan warna kotak tersebut}, label={lst:cellCode}]
		//Merepresentasikan 1 cell/kotak dalam permainan colored queens untuk memudahkan memasukkan data ke dalam Map di dalam object Board
		public class Cell {
			//menyimpan posisi dan warna dari kotak
			private int row;
			private int col;
			private int r;
			private int g;
			private int b;
			
			public Cell(int row, int col, int r, int g, int b) {
				this.row = row;
				this.col = col;
				this.r = r;
				this.g = g;
				this.b = b;
			}
			
			// Getter dan setter
			public int getRow() { 
				return row; 
			}
			
			public void setRow(int row) { 
				this.row = row; 
			}
			
			public int getCol() { 
				return col; 
			}
			
			public void setCol(int col) { 
				this.col = col; 
			}
			
			public int getR() { 
				return r; 
			}
			
			public void setR(int r) { 
				this.r = r; 
			}
			
			public int getG() { 
				return g; 
			}
			
			public void setG(int g) { 
				this.g = g; 
			}
			
			public int getB() { 
				return b; 
			}
			public void setB(int b) { 
				this.b = b; 
			}
			
			@Override
			public String toString() {
				return String.format("Cell[row=%d, col=%d, rgb=(%d,%d,%d)]", row, col, r, g, b);
			}
		}
	\end{lstlisting}
	
	Sebelum mengintegrasikan AC-3 sebagai mekanisme penyempitan ruang solusi ataupun optimasi menggunakan \texttt{BitSet}, sebuah solver Backtracking murni untuk dijadikan \textit{baseline} dalam pengukuran kinerja. Implementasi awal ini menjalankan proses pencarian secara eksploratif tanpa bantuan propagasi kendala tambahan, sehingga karakteristik performanya dapat menjadi pembanding langsung terhadap versi yang telah diperkuat dengan AC-3.
	\begin{lstlisting}[language=java, caption={Solver \textit{backtracking} murni yang diimplementasikan tanpa optimasi apapun, termasuk propagasi kendala atau penggunaan \texttt{BitSet}}, label={lst:btPureCode}]
		public class BacktrackingSolver {
			private Board board;
			private int size;
			private Map<String, List<int[]>> colorCells;
			private List<String> colors;
			private int[] solution;       //solution[colorIndex] = index in color's cell list
			private boolean[][] occupied; //tracks queen positions
			private long steps;
			private long backtracks;
			private long startTime;
			
			public BacktrackingSolver(Board board) {
				this.board = board;
				this.size = board.getSize();
				this.colorCells = board.getColorMap();
				this.colors = new ArrayList<>(colorCells.keySet());
				this.solution = new int[colors.size()];
				Arrays.fill(solution, -1);
				this.occupied = new boolean[size][size];
				this.steps = 0;
				this.backtracks = 0;
			}
			
			//memanggil fungsi rekursif
			public boolean solve() {
				System.out.println("Starting solver for " + size + "x" + size + " board with " + colors.size() + " colors.");
				startTime = System.currentTimeMillis();
				boolean result = placeQueens(0); //hasil fungsi rekursif disimpan di sini
				long endTime = System.currentTimeMillis();
				
				System.out.println("\nSolver stats:");
				System.out.println("Steps: " + steps);
				System.out.println("Backtracks: " + backtracks);
				System.out.println("Time: " + (endTime - startTime) + " ms");
				System.out.println("Solution found: " + result);
				
				return result;
			}
			
			//fungsi backtracking utama
			private boolean placeQueens(int colorIndex) {
				if (colorIndex == colors.size()) {
					return true; //base case
				}
				
				//berbeda dengan N-Queens, domain 1 queen merupakan daerah warna itu sendiri, bukan satu kolom/baris agar tidak perlu mengecek "color constraint" di setiap step
				String color = colors.get(colorIndex);
				List<int[]> cells = colorCells.get(color);
				
				steps++;
				
				
				//mencoba setiap cell yang berwarna sama
				for (int i = 0; i < cells.size(); i++) {
					int row = cells.get(i)[0];
					int col = cells.get(i)[1];
					
					
					//jika posisi valid
					if (isValid(row, col)) {
						solution[colorIndex] = i;
						occupied[row][col] = true;
						
						
						//lanjutkan untuk warna sebelumnya
						if (placeQueens(colorIndex + 1)) {
							return true;
						}
						
						backtracks++;
						solution[colorIndex] = -1;
						occupied[row][col] = false;
					}
				}
				
				return false;
			}
			
			private boolean isValid(int row, int col) {
				//mengecek apakah cell tersebut sudah ada menteri atau belum
				if (occupied[row][col]) {
					return false;
				}
				
				//mengecek semua cell horizontal dan vertikal
				for (int i = 0; i < size; i++) {
					if (occupied[row][i] || occupied[i][col]) {
						return false;
					}
				}
				
				//mengecek apakah ada bidak yang bersebelahan (8 mata angin)
				int[][] dirs = {{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}};
				for (int[] d : dirs) {
					int r = row + d[0];
					int c = col + d[1];
					if (r >= 0 && r < size && c >= 0 && c < size && occupied[r][c]) {
						return false;
					}
				}
				
				return true;
			}
			
			//print hasil akhir papan dengan Q menandakan Bidak menteri
			private void printBoard() {
				System.out.println("Board state:");
				String[][] grid = new String[size][size];
				
				for (Map.Entry<String, List<int[]>> entry : colorCells.entrySet()) {
					String symbol = board.getSymbolForColor(entry.getKey());
					for (int[] cell : entry.getValue()) {
						grid[cell[0]][cell[1]] = symbol;
					}
				}
				
				for (int r = 0; r < size; r++) {
					for (int c = 0; c < size; c++) {
						if (occupied[r][c]) {
							grid[r][c] = "Q";
						}
					}
				}
				
				System.out.print("   ");
				for (int c = 0; c < size; c++) {
					System.out.print(c + " ");
				}
				System.out.println();
				
				for (int r = 0; r < size; r++) {
					System.out.print(r + "  ");
					for (int c = 0; c < size; c++) {
						System.out.print((grid[r][c] != null ? grid[r][c] : ".") + " ");
					}
					System.out.println();
				}
				System.out.println();
			}
			
			//Print posisi akhir semua bidak menteri dalam bentuk per baris
			public void printSolution() {
				if (solution[0] == -1) {
					System.out.println("No solution found!");
					return;
				}
				
				System.out.println("Final solution:");
				for (int i = 0; i < colors.size(); i++) {
					String color = colors.get(i);
					String symbol = board.getSymbolForColor(color);
					int[] cell = colorCells.get(color).get(solution[i]);
					System.out.println("Color " + symbol + " at [" + cell[0] + "," + cell[1] + "]");
				}
				
				printBoard();
			}
			
			public long getSteps() {
				return steps;
			}
			public long getBacktracks() {
				return backtracks;
			}
		}
	\end{lstlisting}
	
	
	Setelah implementasi solver Backtracking murni selesai, dilakukan pengujian khusus pada papan berukuran besar, yaitu $20 \times 20$, seperti pada listing {\ref{lst:20x20boardBaseline}}, dan $30 \times 30$ pada listing {\ref{lst:30x30boardBaseline}}, untuk mengevaluasi batas kemampuan pendekatan ini tanpa bantuan teknik penyempitan ruang solusi. Pengujian ini bertujuan untuk menunjukkan bagaimana kompleksitas eksponensial backtracking berdampak langsung pada waktu eksekusi ketika ukuran papan meningkat secara signifikan.
	\begin{lstlisting}[basicstyle=\ttfamily\scriptsize, caption={Tolok ukur untuk papan $20 \times 20$}, label={lst:20x20boardBaseline}]
		Solver stats:
		Steps: 118401240766
		Backtracks: 118401240746
		Time: 24638023 ms
		Solution found: true
		Final solution:
		Color A at [15,14]
		Color B at [14,1]
		Color C at [17,16]
		Color D at [3,0]
		Color E at [0,12]
		Color F at [10,9]
		Color G at [1,7]
		Color H at [5,8]
		Color I at [6,19]
		Color J at [2,3]
		Color K at [11,17]
		Color L at [16,10]
		Color M at [12,2]
		Color N at [18,11]
		Color O at [8,18]
		Color P at [7,13]
		Color R at [4,15]
		Color S at [13,4]
		Color T at [19,5]
		Color U at [9,6]
		Board state:
		0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
		0  J J J J J J J G G G G G Q E E E I I I I
		1  J J J J J J J Q G G G E E E E E I I I I
		2  J J J Q J J J G G G G E E E E E I I I I
		3  Q D D J J J J G G E E E E E R R R I I I
		4  D D D D D D D D G H E R R R R Q R I I I
		5  D D D D D D U U Q H H H P P R R R O I I
		6  D D D D D U U U H H H H P P P P P O O Q
		7  D D D D U U U U H H H H H Q P O O O O O
		8  D D D D S U U U U H H H H P P O O O Q O
		9  M D S S S U Q U U U H H H P K K K O O O
		10  M M S S S S U U U Q H H H K K K K K K K
		11  M S S S S S S F F F L H K K K K K Q K K
		12  M M Q S S S F F F F L L L K K K K K K K
		13  M M M S Q T F F F L L L L L K K K K C C
		14  M Q B B T T L L L L L L L L L K K C C C
		15  B B B B T T T L L L L L L L Q A C C C C
		16  B B B T T T T T N L Q L L A A A C C C C
		17  B B B T T T T N N N N N A A A A Q C C C
		18  B B B T T T N N N N N Q A A A A A C C C
		19  B B B T T Q N N N N N A A A A A A A C C
		
		
		BUILD SUCCESSFUL in 6h 50m 39s
	\end{lstlisting}
	
	\begin{lstlisting}[basicstyle=\ttfamily\scriptsize, caption={Tolok ukur untuk papan $30 \times 30$}, label={lst:30x30boardBaseline}]
		Solver stats:
		Steps: 429459387595
		Backtracks: 429459387565
		Time: 175308806 ms
		Solution found: true
		Final solution:
		Color A at [21,22]
		Color B at [15,9]
		Color C at [6,15]
		Color D at [7,10]
		Color E at [26,4]
		Color F at [0,11]
		Color G at [9,3]
		Color H at [19,28]
		Color I at [1,0]
		Color J at [27,7]
		Color K at [28,26]
		Color L at [18,23]
		Color M at [22,1]
		Color N at [29,13]
		Color O at [4,16]
		Color P at [11,25]
		Color R at [10,21]
		Color S at [20,20]
		Color T at [23,12]
		Color U at [14,19]
		Color V at [3,24]
		Color W at [2,17]
		Color X at [25,2]
		Color Y at [24,18]
		Color Z at [13,27]
		Color [ at [12,14]
		Color \ at [16,5]
		Color ] at [17,29]
		Color ^ at [5,8]
		Color _ at [8,6]
		Board state:
		0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29
		0  I I I I I I I ^ ^ ^ ^ Q F F W W W W W W V V V V V V V V V V
		1  Q I I I I I ^ ^ ^ ^ ^ F F F F W W W W V V V V V V V V V V V
		2  I I I I _ _ ^ ^ ^ ^ ^ F F F F F W Q V V V V V V V V V V V V
		3  I I I I _ _ _ ^ ^ ^ ^ F F F F F F W V V V V V V Q V V V V Z
		4  I I I _ _ _ _ ^ ^ ^ ^ ^ F F O O Q O V V V V V V V V V Z Z Z
		5  I I _ _ _ _ _ _ Q ^ ^ O O O O O O O O V V V V V V Z Z Z Z Z
		6  I _ _ _ _ _ _ _ ^ ^ D [ [ O O Q C C C C V V V V Z Z Z Z Z Z
		7  I _ _ _ _ _ _ _ ^ ^ Q [ [ [ C C C C C C C V R R Z Z Z Z Z Z
		8  _ _ _ _ _ _ Q D D D D [ [ [ C C C C C C C R R R Z Z Z Z Z Z
		9  \ _ _ Q G G G G D D D D [ [ C C C C U U R R R R Z Z Z Z Z Z
		10  \ \ G G G G G G G D D D [ [ [ C C C U U R Q R R Z Z Z Z Z Z
		11  \ \ G G G G G G G D D D [ [ [ C C U U U R R R R R Q Z Z Z Z
		12  \ \ \ \ G G G G G G D D [ [ Q U U U U U R R R R R P P Z Z Z
		13  \ \ \ \ \ G G G G G D D [ U U U U U U U U R R R P P P Q Z Z
		14  \ \ \ \ \ \ G G G G D D [ [ U U U U U Q U R R P P P P P P P
		15  \ \ \ \ \ \ G G G Q D D [ [ U U U U U U U R R P P P ] ] ] ]
		16  \ \ \ \ \ Q \ B B B T T T T U Y Y U Y U S S L L L ] ] ] ] ]
		17  M M \ \ \ \ \ B B B B T T T Y Y Y Y Y S S S L L L L ] ] ] Q
		18  M M M M M M B B B B T T T T Y Y Y Y Y S S S S Q L L ] ] ] ]
		19  M M M M M M B B B B T T T T Y Y Y Y Y Y S S S L L L ] ] Q H
		20  M M M M M B B B B B T T T T Y Y Y Y Y Y Q S S L L L ] H H H
		21  M M M X X B B B B B T T T T T Y Y Y Y Y Y Y Q A L L H H H H
		22  M Q X X X X B B B B T T T T T T Y Y Y Y Y Y A A A H H H H H
		23  X X X X X X B B B T T T Q T T N N Y Y Y Y A A A A H H H H H
		24  X X X X X X X B B T T T T T N N N N Q A A A A A A A H H H H
		25  X X Q X X X X J B T T T T T N N N N N A A A A A A A A K K K
		26  X X X X Q E J J J J T T N N N N N N N N A A A A A A K K K K
		27  E E E E E E E Q J J J N N N N N N N N N N A A A A A K K K K
		28  E E E E E E E J J J J J N N N N N N N N N A A A A A Q K K K
		29  E E E E E J J J J J J J J Q N N N N N N N A A A A A K K K K
		
		
		BUILD SUCCESSFUL in 48h 41m 50s
	\end{lstlisting}
		
	
	\section{Pencapaian Rencana Kerja}
	Langkah-langkah kerja yang berhasil diselesaikan dalam Tugas Akhir 1 ini adalah sebagai berikut:
	\begin{enumerate}
		\item Melakukan studi literatur terkait permasalahan n-queens dan variannya, Constraint Satisfaction Problem (CSP), algoritma pencarian Backtracking, teknik metaheuristik Particle Swarm Optimization, serta metode propagasi kendala AC-3.
		\item Mengumpulkan dan menyusun berbagai skenario permasalahan Colored Queens yang akan digunakan sebagai basis pengujian algoritma serta sebagai pilihan tingkat kesulitan bagi pengguna.
		\item Melakukan pemodelan masalah Colored Queens ke dalam bentuk CSP agar dapat diproses oleh algoritma pencarian.
		\item Melakukan analisis kebutuhan perangkat lunak, baik fungsional maupun non-fungsional, termasuk kebutuhan solver dan antarmuka pengguna.
		\item Merancang arsitektur sistem serta antarmuka pengguna untuk aplikasi Colored Queens Solver.
		\item Menyusun dokumentasi tugas akhir untuk tahap TA 1.
	\end{enumerate}
	
	\vspace{1cm}
	\centering Bandung, \tanggal\\
	\vspace{2cm} \nama \\ 
	\vspace{1cm}
	
	Menyetujui, \\
	\ifdefstring{\jumpemb}{2}{
		\vspace{1.5cm}
		\begin{centering} Menyetujui,\\ \end{centering} \vspace{0.75cm}
		\begin{minipage}[b]{0.45\linewidth}
			% \centering Bandung, \makebox[0.5cm]{\hrulefill}/\makebox[0.5cm]{\hrulefill}/2013 \\
			\vspace{2cm} Nama: \pembA \\ Pembimbing Utama
		\end{minipage} \hspace{0.5cm}
		\begin{minipage}[b]{0.45\linewidth}
			% \centering Bandung, \makebox[0.5cm]{\hrulefill}/\makebox[0.5cm]{\hrulefill}/2013\\
			\vspace{2cm} Nama: \pembB \\ Pembimbing Pendamping
		\end{minipage}
		\vspace{0.5cm}
	}{
		% \centering Bandung, \makebox[0.5cm]{\hrulefill}/\makebox[0.5cm]{\hrulefill}/2013\\
		\vspace{2cm} Nama: \pembA \\ Pembimbing Tunggal
	}
\end{document}
